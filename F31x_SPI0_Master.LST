C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE F31X_SPI0_MASTER
OBJECT MODULE PLACED IN F31x_SPI0_Master.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe F31x_SPI0_Master.c DB OE BR INCDIR(c:\SiLabs\MCU\Inc)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F31x_SPI0_Master.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2006 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          //
   7          // Program Description:
   8          //
   9          // This program configures a C8051F31x as a 4-wire SPI Single Master.
  10          //
  11          // The SPI clock in this example is limited to 500 kHz when used with the
  12          // SPI0_Slave code example.  During a SPI_Read, the slave needs some time to
  13          // interpret the command and write the appropriate data to the SPI0DAT
  14          // register, and the slave no longer has enough time to complete the
  15          // SPI_READ_BUFFER command with a clock greater than 500 kHz.  For faster SPI
  16          // clocks, a dummy byte between the command and the first byte of Read data
  17          // will be required.
  18          //
  19          // This example is intended to be used with the SPI0_Slave example.
  20          //
  21          // Pinout:
  22          //
  23          // P0.0 - SPI SCK    (digital output, push-pull)
  24          // P0.1 - SPI MISO   (digital input, open-drain)
  25          // P0.2 - SPI MOSI   (digital output, push-pull)
  26          // P0.3 - SPI NSS    (digital output, push-pull)
  27          //
  28          // P3.3 - LED        (digital output, push-pull)
  29          //
  30          // all other port pins unused.
  31          //
  32          //
  33          // How To Test:
  34          //
  35          // 1) Download the code to a F310-TB that is connected as above to
  36          //    another device running the SPI0_Slave code.
  37          // 2) Verify the LED pins of jumper J3 are populated.
  38          // 3) Verify J9 and J10 are populated.
  39          // 4) Run the code.
  40          // 5) If the communication passes, the LEDs on both the Master and Slave
  41          //    boards will blink slowly. If it fails, the LEDs will be OFF.
  42          //
  43          //
  44          // Target:         C8051F31x
  45          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  46          // Command Line:   None
  47          //
  48          // Release 1.0
  49          //    -Initial Revision (TP)
  50          //    -12 DEC 2006
  51          //
  52          
  53          //-----------------------------------------------------------------------------
  54          // Includes
  55          //-----------------------------------------------------------------------------
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 2   

  56          
  57          #include <C8051F310.h>                 // SFR declarations
  58          
  59          //-----------------------------------------------------------------------------
  60          // Global Constants
  61          //-----------------------------------------------------------------------------
  62          
  63          #define SYSCLK             24500000    // Internal oscillator frequency in Hz
  64          
  65          #define SPI_CLOCK          500000      // Maximum SPI clock
  66                                                 // The SPI clock is a maximum of 500 kHz
  67                                                 // when this example is used with
  68                                                 // the SPI0_Slave code example.
  69          
  70          #define MAX_BUFFER_SIZE    8           // Maximum buffer Master will send
  71          
  72          // Instruction Set
  73          #define  SLAVE_LED_ON      0x01        // Turn the Slave LED on
  74          #define  SLAVE_LED_OFF     0x02        // Turn the Slave LED off
  75          #define  SPI_WRITE         0x04        // Send a byte from the Master to the
  76                                                 // Slave
  77          #define  SPI_READ          0x08        // Send a byte from the Slave to the
  78                                                 // Master
  79          #define  SPI_WRITE_BUFFER  0x10        // Send a series of bytes from the
  80                                                 // Master to the Slave
  81          #define  SPI_READ_BUFFER   0x20        // Send a series of bytes from the Slave
  82                                                 // to the Master
  83          #define  ERROR_OCCURRED    0x40        // Indicator for the Slave to tell the
  84                                                 // Master an error occurred
  85          
  86          sbit LED = P3^3;                       // LED='1' means ON
  87          
  88          
  89          //-----------------------------------------------------------------------------
  90          // Global Variables
  91          //-----------------------------------------------------------------------------
  92          
  93          unsigned char SPI_Data = 0xA5;
  94          
  95          unsigned char SPI_Data_Array[MAX_BUFFER_SIZE] = {0};
  96          
  97          bit Error_Flag = 0;
  98          
  99          unsigned char Command = 0x00;
 100          
 101          //-----------------------------------------------------------------------------
 102          // Function Prototypes
 103          //-----------------------------------------------------------------------------
 104          
 105          void PCA0_Init (void);
 106          void Oscillator_Init (void);
 107          void Port_Init (void);
 108          void SPI0_Init (void);
 109          void Init_Device (void);
 110          
 111          void SPI_LED_On (void);
 112          void SPI_LED_Off (void);
 113          void SPI_Byte_Write (unsigned char addr);
 114          void SPI_Byte_Read (unsigned char addr);
 115          void SPI_Array_Write (void);
 116          void SPI_Array_Read (void);
 117          
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 3   

 118          void Delay(void);
 119          
 120          //-----------------------------------------------------------------------------
 121          // main() Routine
 122          //-----------------------------------------------------------------------------
 123          void main (void)
 124          {
 125   1         unsigned char test_value = 0x55;
 126   1         unsigned char test_array[MAX_BUFFER_SIZE] = {1,2,3,4,5,6,7,8};
 127   1         unsigned char i;
 128   1         unsigned char x1,x2,y1,y2,z1,z2;
 129   1         int x,y,z;
 130   1      
 131   1         Init_Device ();                     // Initializes hardware peripherals
 132   1      
 133   1         EA = 1;                             // Enable global interrupts
 134   1      
 135   1         LED = 0;
 136   1      
 137   1         // TEST BEGIN --------------------------------------------------------------
 138   1      
 139   1         
 140   1      
 141   1         NSSMD0 = 1;
 142   1      
 143   1         SPI_Byte_Read (0x00);
 144   1      
 145   1                            // Wait until the Read transfer has
 146   1      
 147   1      
 148   1         SPI_Data = 0x03; //met le bit 6 a 0 sur ladresse 31, indique au gyro qu'on fonctionne en 4wire
 149   1         //& range de +/- 16g et resolution à 10bits
 150   1         // Write a value
 151   1         SPI_Byte_Write (0x31);
 152   1                      // Wait until the Write transfer has
 153   1                                            // finished
 154   1      
 155   1              SPI_Data = 0x20;//Mode bypass & interruption used INT2
 156   1         // Write a value
 157   1         SPI_Byte_Write (0x38);
 158   1                      // Wait until the Write transfer has
 159   1                                            // finished
 160   1              SPI_Data = 0x0A;//bit d4=0 normal power
 161   1         // Write a value
 162   1         SPI_Byte_Write (0x2C);
 163   1                      // Wait until the Write transfer has
 164   1                                            // finished
 165   1                      SPI_Data = 0x08;//measurement mode on
 166   1         // Write a value
 167   1         SPI_Byte_Write (0x2D);
 168   1         // Read the same value back
 169   1      
 170   1         SPI_Data = 0x00;
 171   1         SPI_Byte_Read (0x32);
 172   1                      // Wait until the Read transfer has
 173   1                                             // finished
 174   1              x1=SPI_Data;
 175   1              // Read the same value back
 176   1         SPI_Data = 0x00;
 177   1         SPI_Byte_Read (0x33);
 178   1                      // Wait until the Read transfer has
 179   1                                             // finished
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 4   

 180   1              x2=SPI_Data;
 181   1      // Read the same value back
 182   1         SPI_Data = 0x00;
 183   1         SPI_Byte_Read (0x34);
 184   1                      // Wait until the Read transfer has
 185   1                                             // finished
 186   1              y1=SPI_Data;
 187   1      // Read the same value back
 188   1         SPI_Data = 0x00;
 189   1         SPI_Byte_Read (0x35);
 190   1                      // Wait until the Read transfer has
 191   1                                             // finished
 192   1              y2=SPI_Data;
 193   1              // Read the same value back
 194   1         SPI_Data = 0x00;
 195   1         SPI_Byte_Read (0x36);
 196   1                      // Wait until the Read transfer has
 197   1                                             // finished
 198   1              z1=SPI_Data;
 199   1              // Read the same value back
 200   1         SPI_Data = 0x00;
 201   1         SPI_Byte_Read (0x37);
 202   1         z2=SPI_Data;
 203   1                      // Wait until the Read transfer has
 204   1                                             // finished
 205   1                           // finished
 206   1              //The ADXL345 gives 10-bit acceleration values, but they are stored as bytes (8-bits). To get the full va
             -lue, two bytes must be combined for each axis.
 207   1        //The X value is stored in values[0] and values[1].
 208   1        x = ((int)x2<<8)|(int)x1;
 209   1        //The Y value is stored in values[2] and values[3].
 210   1        y = ((int)y2<<8)|(int)y1;
 211   1        //The Z value is stored in values[4] and values[5].
 212   1        z = ((int)z2<<8)|(int)z1;
 213   1        x=(int)(x*31.2);
 214   1        y=(int)(y*31.2);
 215   1        z=(int)(z*31.2);
 216   1              while (1);
 217   1         // Check if the sent value and returned value match
 218   1         if (SPI_Data != test_value)
 219   1         {
 220   2            Error_Flag = 1;
 221   2         }
 222   1      
 223   1         // Copy test_array into SPI_Data_Array
 224   1         for (i = 0; i < MAX_BUFFER_SIZE; i++)
 225   1         {
 226   2            SPI_Data_Array[i] = test_array[i];
 227   2         }
 228   1      
 229   1         // Send the array to the slave
 230   1         SPI_Array_Write ();
 231   1      
 232   1         while (!NSSMD0);                    // Wait until the Write transfer has
 233   1                                             // finished
 234   1      
 235   1         // Clear SPI_Data_Array for the SPI_Buffer_Read function
 236   1         for (i = 0; i < MAX_BUFFER_SIZE; i++)
 237   1         {
 238   2            SPI_Data_Array[i] = 0;
 239   2         }
 240   1      
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 5   

 241   1         // Read the array back from the slave
 242   1         SPI_Array_Read ();
 243   1      
 244   1         while (!NSSMD0);                    // Wait until the Read transfer has
 245   1                                             // finished
 246   1      
 247   1         // Check if the received array matches the sent array
 248   1         for (i = 0; i < MAX_BUFFER_SIZE; i++)
 249   1         {
 250   2            if (SPI_Data_Array[i] != test_array[i])
 251   2            {
 252   3               Error_Flag = 1;
 253   3            }
 254   2         }
 255   1      
 256   1         // END OF TEST -------------------------------------------------------------
 257   1      
 258   1         while (1)
 259   1         {
 260   2            // If no error has occurred, blink the LEDs on the Master and Slave
 261   2            // boards
 262   2            if (Error_Flag == 0)
 263   2            {
 264   3               LED = 1;
 265   3      
 266   3               SPI_LED_On ();
 267   3      
 268   3               while (!NSSMD0);
 269   3      
 270   3               Delay ();
 271   3      
 272   3               SPI_LED_Off ();
 273   3      
 274   3               LED = 0;
 275   3      
 276   3               while (!NSSMD0);
 277   3      
 278   3               Delay ();
 279   3            }
 280   2         };
 281   1      }
 282          
 283          //-----------------------------------------------------------------------------
 284          // Initialization Subroutines
 285          //-----------------------------------------------------------------------------
 286          
 287          //-----------------------------------------------------------------------------
 288          // PCA0_Init
 289          //-----------------------------------------------------------------------------
 290          //
 291          // Return Value : None
 292          // Parameters   : None
 293          //
 294          // This function disables the watchdog timer.
 295          //
 296          //-----------------------------------------------------------------------------
 297          void PCA0_Init (void)
 298          {
 299   1         PCA0MD &= ~0x40;                    // Disable the Watchdog Timer
 300   1         PCA0MD = 0x00;
 301   1      }
 302          
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 6   

 303          //-----------------------------------------------------------------------------
 304          // Oscillator_Init
 305          //-----------------------------------------------------------------------------
 306          //
 307          // Return Value : None
 308          // Parameters   : None
 309          //
 310          // This function initializes the system clock to use the internal oscillator
 311          // at 24.5 MHz.
 312          //
 313          //-----------------------------------------------------------------------------
 314          void Oscillator_Init (void)
 315          {
 316   1         OSCICN = 0x83;                      // Set the internal oscillator to
 317   1                                             // 24.5 MHz
 318   1      }
 319          
 320          //-----------------------------------------------------------------------------
 321          // Port_Init
 322          //-----------------------------------------------------------------------------
 323          //
 324          // Return Value : None
 325          // Parameters   : None
 326          //
 327          // This function configures the crossbar and GPIO ports.
 328          //
 329          // P0.0  -  SCK  (SPI0), Push-Pull,  Digital
 330          // P0.1  -  MISO (SPI0), Open-Drain, Digital
 331          // P0.2  -  MOSI (SPI0), Push-Pull,  Digital
 332          // P0.3  -  NSS  (SPI0), Push-Pull,  Digital
 333          //
 334          // P3.3  -  LED,         Push-Pull,  Digital (LED D2 on Target Board)
 335          //
 336          //-----------------------------------------------------------------------------
 337          void PORT_Init (void)
 338          {
 339   1         P1MDOUT = 0x0D;                     // Make SCK, MOSI, and NSS push-pull
 340   1         P3MDOUT = 0x08;                     // Make the LED push-pull
 341   1      
 342   1         //XBR0 = 0x02;                        // Enable the SPI on the XBAR
 343   1         //XBR1 = 0x40;                        // Enable the XBAR and weak pull-ups
 344   1      
 345   1         
 346   1              XBR0=0x03;           //enable uart and spi
 347   1              XBR1=0x40;  
 348   1              P0SKIP=0xCF;        //decale de maniere a avoir le spi0 sur port 1          
 349   1      }
 350          
 351          //-----------------------------------------------------------------------------
 352          // SPI0_Init
 353          //-----------------------------------------------------------------------------
 354          //
 355          // Return Value : None
 356          // Parameters   : None
 357          //
 358          // Configures SPI0 to use 4-wire Single Master mode. The SPI timing is
 359          // configured for Mode 0,0 (data centered on first edge of clock phase and
 360          // SCK line low in idle state).
 361          //
 362          //-----------------------------------------------------------------------------
 363          void SPI0_Init()
 364          {
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 7   

 365   1         SPI0CFG   = 0x70;                   // Enable the SPI as a Master
 366   1                                             // CKPHA = '0', CKPOL = '0'
 367   1         SPI0CN    = 0x09;                   // 4-wire Single Master, SPI enabled
 368   1      
 369   1         // SPI clock frequency equation from the datasheet
 370   1         SPI0CKR   = (SYSCLK/(2*SPI_CLOCK))-1;
 371   1      
 372   1         ESPI0 = 1;                          // Enable SPI interrupts
 373   1      
 374   1      
 375   1      /*
 376   1      SPI0CN|=0x08;   //p181 , NSSMD=1X, 4 wire master mode
 377   1      SPI0CFG|=0x70;  //mode de communication(178), demandé par l'oscillo p15 touche a CKPOL=1, CKPHA=1     MSTE
             -N=1, opere en mode master
 378   1      SPI0CN|=0x01;    //SPIEN=1 spi enabled
 379   1      SPI0CKR=0x01;   //p182 divide clock by 4 in SPI transmission
 380   1      */
 381   1      }
 382          
 383          //-----------------------------------------------------------------------------
 384          // Init_Device
 385          //-----------------------------------------------------------------------------
 386          //
 387          // Return Value : None
 388          // Parameters   : None
 389          //
 390          // Calls all device initialization functions.
 391          //
 392          //-----------------------------------------------------------------------------
 393          void Init_Device (void)
 394          {
 395   1         PCA0_Init ();                       // Disable the Watchdog Timer first
 396   1         Oscillator_Init ();
 397   1         Port_Init ();
 398   1         SPI0_Init ();
 399   1      }
 400          
 401          //-----------------------------------------------------------------------------
 402          // Interrupt Service Routines
 403          //-----------------------------------------------------------------------------
 404          
 405          //-----------------------------------------------------------------------------
 406          // SPI_ISR
 407          //-----------------------------------------------------------------------------
 408          //
 409          // Handles all error checks and single-byte writes.
 410          //
 411          // Note: SPI_WRITE_ARRAY is not handled by this ISR in order to take
 412          // advantage of double-buffering (checking the TXBMT flag) using polling.
 413          //
 414          //
 415          // Typical Write:
 416          //
 417          //              | 1st sent | 2nd sent | 3rd sent |   ...    | last sent |
 418          //              ---------------------------------------------------------
 419          //  Master NSSv | Command  |   Data1  |   Data2  |   ...    |   DataN   |  NSS^
 420          //  Slave       |   N/A    |    N/A   |    N/A   |   ...    |    N/A    |
 421          //
 422          // Typical Read:
 423          //
 424          //              | 1st sent | 2nd sent | 3rd sent |   ...    | last sent |
 425          //              ---------------------------------------------------------
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 8   

 426          //  Master NSSv | Command  |   dummy  |   dummy  |   ...    |   dummy   |  NSS^
 427          //  Slave       |   N/A    |   Data1  |   Data2  |   ...    |   DataN   |
 428          //-----------------------------------------------------------------------------
 429          void SPI_ISR (void) interrupt 6
 430          {
 431   1         static unsigned char array_index = 0;
 432   1         static char state = 0;
 433   1      
 434   1         if (WCOL == 1)
 435   1         {
 436   2            // Write collision occurred
 437   2            WCOL = 0;                        // Clear the write collision flag
 438   2      
 439   2            Error_Flag = 1;
 440   2         }
 441   1         else
 442   1         {
 443   2            if (SPI0DAT == ERROR_OCCURRED)
 444   2            {
 445   3               // This example recognizes when an error occurs, but does not include
 446   3               // any error handling.  The transfer can be aborted or rescheduled,
 447   3               // if desired.
 448   3               Error_Flag = 1;
 449   3            }
 450   2      
 451   2            // When the Master enters the ISR, the SPIF flag should be set from
 452   2            // sending the Command byte.  This ISR handles the remaining steps of the
 453   2            // SPI transfer process.
 454   2            // <state> == 0: writing or reading 1 byte of data
 455   2            // <state> == 1: for READ commands (first time, only a dummy byte is
 456   2            //               sent but the second time, the data must be read from
 457   2            //               SPI0DAT)
 458   2            // <state> == 2: NSS = 1 to end the transfer, final byte read
 459   2            //
 460   2            // Note: SPI_WRITE_BUFFER is not handled here because it's done in
 461   2            // polled mode
 462   2            if (state == 0)
 463   2            {
 464   3               switch (Command)
 465   3               {
 466   4                  case SLAVE_LED_ON:
 467   4                  case SLAVE_LED_OFF:
 468   4                     NSSMD0 = 1;             // Release the slave (not expecting
 469   4                                             // data back)
 470   4      
 471   4                     break;
 472   4      
 473   4                  case SPI_WRITE:
 474   4                     SPI0DAT = SPI_Data;
 475   4      
 476   4                     state = 2;              // Advance to the final state (only
 477   4                                             // writing one byte)
 478   4      
 479   4                     break;
 480   4      
 481   4                  case SPI_READ:
 482   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 483   4                                             // send the data
 484   4      
 485   4                     state = 2;              // Advance to the final state (only
 486   4                                             // reading one byte)
 487   4      
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 9   

 488   4                     break;
 489   4      
 490   4                  case SPI_READ_BUFFER:
 491   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 492   4                                             // start sending the data
 493   4      
 494   4                     state = 1;              // Advance to the next state where the
 495   4                                             // data can be received
 496   4                                             // The data from the slave is not
 497   4                                             // available until after the second
 498   4                                             // transfer is completed.
 499   4                                             // The dummy byte allows the slave to
 500   4                                             // send data, since the Master controls
 501   4                                             // SCK.
 502   4      
 503   4                     break;
 504   4      
 505   4                  default:
 506   4                     state = 2;              // Any errors in the Command parsing
 507   4                                             // should go to state 2 where NSSMD0
 508   4                                             // is de-asserted
 509   4               }
 510   3            }
 511   2            else if (state == 1)             // This state is for READ_ARRAY
 512   2            {                                // commands where the data must be read
 513   3                                             // after the first dummy byte is sent
 514   3               switch (Command)
 515   3               {
 516   4                  case SPI_READ_BUFFER:
 517   4                     SPI_Data_Array[array_index] = SPI0DAT;
 518   4                     SPI0DAT = 0xFF;
 519   4      
 520   4                     array_index++;
 521   4      
 522   4                     if (array_index == (MAX_BUFFER_SIZE-1))
 523   4                     {
 524   5                        state = 2;
 525   5                     }
 526   4      
 527   4                     break;
 528   4                  default:
 529   4                     state = 2;              // Any errors in the Command parsing
 530   4                                             // should go to state 2 where NSSMD0
 531   4                                             // is de-asserted
 532   4               }
 533   3            }
 534   2            else if (state == 2)
 535   2            {
 536   3               switch (Command)
 537   3               {
 538   4                  case SPI_READ:
 539   4                     SPI_Data = SPI0DAT;     // Read the data from the slave
 540   4      
 541   4                     break;
 542   4      
 543   4                  case SPI_READ_BUFFER:
 544   4                     SPI_Data_Array[array_index] = SPI0DAT; // Read the last data
 545   4                                                            // without sending a
 546   4                                                            // dummy byte
 547   4      
 548   4                     break;
 549   4               }
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 10  

 550   3      
 551   3               NSSMD0 = 1;                   // De-select the Slave
 552   3      
 553   3               state = 0;                    // Reset the state
 554   3            }
 555   2      
 556   2            SPIF = 0;                        // Clear the SPIF flag
 557   2         }
 558   1      }
 559          
 560          //-----------------------------------------------------------------------------
 561          // Support Routines
 562          //-----------------------------------------------------------------------------
 563          
 564          //-----------------------------------------------------------------------------
 565          // SPI_LED_On
 566          //-----------------------------------------------------------------------------
 567          //
 568          // Return Value : None
 569          // Parameters   : None
 570          //
 571          // Turns the LED on the SPI Slave on.  The slave does not respond to this
 572          // command, so the command consists of:
 573          //
 574          // Command = SLAVE_LED_ON
 575          // Length = 1 byte (the command itself)
 576          //
 577          //-----------------------------------------------------------------------------
 578          void SPI_LED_On (void)
 579          {
 580   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 581   1                                             // it's already busy
 582   1      
 583   1         NSSMD0 = 0;
 584   1      
 585   1         Command = SLAVE_LED_ON;
 586   1      
 587   1         SPI0DAT = Command;
 588   1      
 589   1         // The rest of this command will be handled by the SPI ISR, which will
 590   1         // trigger when SPIF is set from sending the Command
 591   1      }
 592          
 593          //-----------------------------------------------------------------------------
 594          // SPI_LED_Off
 595          //-----------------------------------------------------------------------------
 596          //
 597          // Return Value : None
 598          // Parameters   : None
 599          //
 600          // Turns the LED on the SPI Slave off.  The slave does not respond to this
 601          // command, so the command consists of:
 602          //
 603          // Command = SLAVE_LED_OFF
 604          // Length = 1 byte (the command itself)
 605          //
 606          //-----------------------------------------------------------------------------
 607          void SPI_LED_Off (void)
 608          {
 609   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 610   1                                             // it's already busy
 611   1      
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 11  

 612   1         NSSMD0 = 0;
 613   1      
 614   1         Command = SLAVE_LED_OFF;
 615   1      
 616   1         SPI0DAT = Command;
 617   1      
 618   1         // The rest of this command will be handled by the SPI ISR, which will
 619   1         // trigger when SPIF is set from sending the Command
 620   1      }
 621          
 622          //-----------------------------------------------------------------------------
 623          // SPI_Byte_Write
 624          //-----------------------------------------------------------------------------
 625          //
 626          // Return Value : None
 627          // Parameters   : None
 628          //
 629          // Note: SPI_Data must contain the data to be sent before calling this
 630          // function.
 631          //
 632          // Writes a single byte to the SPI Slave.  The slave does not respond to this
 633          // command, so the command consists of:
 634          //
 635          // Command = SPI_WRITE
 636          // Length = 1 byte of command, 1 byte of data
 637          //
 638          //-----------------------------------------------------------------------------
 639          void SPI_Byte_Write (unsigned char addr)
 640          {
 641   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 642   1                                             // it's already busy
 643   1      
 644   1         NSSMD0 = 0;
 645   1      
 646   1         Command = SPI_WRITE;
 647   1      
 648   1         SPI0DAT = addr;
 649   1      
 650   1         while (!NSSMD0); 
 651   1      
 652   1         // The rest of this command will be handled by the SPI ISR, which will
 653   1         // trigger when SPIF is set from sending the Command
 654   1      }
 655          
 656          //-----------------------------------------------------------------------------
 657          // SPI_Byte_Read
 658          //-----------------------------------------------------------------------------
 659          //
 660          // Return Value : None
 661          // Parameters   : None
 662          //
 663          // Note: SPI_Data will contain the data received after calling this function.
 664          //
 665          // Reads a single byte from the SPI Slave.  The command consists of:
 666          //
 667          // Command = SPI_READ
 668          // Length = 1 byte of command, 1 byte of data
 669          //
 670          //-----------------------------------------------------------------------------
 671          void SPI_Byte_Read (unsigned char addr)
 672          {
 673   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 12  

 674   1                                             // it's already busy
 675   1      
 676   1         NSSMD0 = 0;
 677   1      
 678   1         Command = SPI_READ;
 679   1      
 680   1         SPI0DAT = 0x80 | addr;
 681   1      
 682   1         while (!NSSMD0); 
 683   1      
 684   1         // The rest of this command will be handled by the SPI ISR, which will
 685   1         // trigger when SPIF is set from sending the Command
 686   1      }
 687          
 688          //-----------------------------------------------------------------------------
 689          // SPI_Array_Write
 690          //-----------------------------------------------------------------------------
 691          //
 692          // Return Value : None
 693          // Parameters   : None
 694          //
 695          // Note: SPI_Data_Array must contain the data to be sent before calling this
 696          // function.
 697          //
 698          // Writes an array of values of size MAX_BUFFER_SIZE to the SPI Slave.  The
 699          // command consists of:
 700          //
 701          // Command = SPI_WRITE_BUFFER
 702          // Length = 1 byte of command, MAX_BUFFER_SIZE bytes of data
 703          //
 704          // Note: Polled mode is used for this function in order to buffer the data
 705          // being sent using the TXBMT flag.
 706          //
 707          //-----------------------------------------------------------------------------
 708          void SPI_Array_Write (void)
 709          {
 710   1         unsigned char array_index;
 711   1      
 712   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 713   1                                             // it's already busy
 714   1      
 715   1         ESPI0 = 0;                          // Disable SPI interrupts
 716   1      
 717   1         NSSMD0 = 0;
 718   1      
 719   1         SPI0DAT = SPI_WRITE_BUFFER;         // Load the XMIT register
 720   1         while (TXBMT != 1)                  // Wait until the command is moved into
 721   1         {                                   // the XMIT buffer
 722   2         }
 723   1      
 724   1         for (array_index = 0; array_index < MAX_BUFFER_SIZE; array_index++)
 725   1         {
 726   2            SPI0DAT = SPI_Data_Array[array_index]; // Load the data into the buffer
 727   2            while (TXBMT != 1)               // Wait until the data is moved into
 728   2            {                                // the XMIT buffer
 729   3            }
 730   2         }
 731   1         SPIF = 0;
 732   1         while (SPIF != 1)                   // Wait until the last byte of the
 733   1         {                                   // data reaches the Slave
 734   2         }
 735   1         SPIF = 0;
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 13  

 736   1      
 737   1         NSSMD0 = 1;                         // Diable the Slave
 738   1      
 739   1         ESPI0 = 1;                          // Re-enable SPI interrupts
 740   1      }
 741          
 742          //-----------------------------------------------------------------------------
 743          // SPI_Array_Read
 744          //-----------------------------------------------------------------------------
 745          //
 746          // Return Value : None
 747          // Parameters   : None
 748          //
 749          // Note: SPI_Data_Array will contain the data received after calling this
 750          // function.
 751          //
 752          // Reads a single byte from the SPI Slave.  The command consists of:
 753          //
 754          // Command = SPI_READ_BUFFER
 755          // Length = 1 byte of command, MAX_BUFFER_SIZE bytes of data
 756          //
 757          //-----------------------------------------------------------------------------
 758          void SPI_Array_Read (void)
 759          {
 760   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 761   1                                             // it's already busy
 762   1      
 763   1         NSSMD0 = 0;
 764   1      
 765   1         Command = SPI_READ_BUFFER;
 766   1      
 767   1         SPI0DAT = Command;
 768   1      
 769   1         // The rest of this command will be handled by the SPI ISR, which will
 770   1         // trigger when SPIF is set from sending the Command
 771   1      }
 772          
 773          //-----------------------------------------------------------------------------
 774          // Delay
 775          //-----------------------------------------------------------------------------
 776          //
 777          // Return Value : None
 778          // Parameters   : None
 779          //
 780          // Delay for little while (used for blinking the LEDs)
 781          //
 782          //-----------------------------------------------------------------------------
 783          void Delay (void)
 784          {
 785   1         unsigned long count;
 786   1      
 787   1         for (count = 200000; count > 0; count--);
 788   1      }
 789          
 790          //-----------------------------------------------------------------------------
 791          // End Of File
 792          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    616    ----
   CONSTANT SIZE    =      8    ----
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 17:23:24 PAGE 14  

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/29/2015 23:27:48 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE F31X_SPI0_MASTER
OBJECT MODULE PLACED IN F31x_SPI0_Master.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe F31x_SPI0_Master.c DB OE BR INCDIR(c:\SiLabs\MCU\Inc)

line level    source

   1          
   2          #include <C8051F310.h>               
   3          #include "stdio.h"
   4          #include "math.h"
   5          
   6          //-----------------------------------------------------------------------------
   7          // Global Constants
   8          //-----------------------------------------------------------------------------
   9          
  10          #define SYSCLK             24500000    // Internal oscillator frequency in Hz
  11          
  12          #define SPI_CLOCK          5000000      // Maximum SPI clock
  13          
  14          #define MAX_BUFFER_SIZE    6           // Maximum buffer Master SPI will receive
  15          
  16          // Instruction Set for SPI
  17          #define  SPI_WRITE         0x04        // Send a byte from the Master to the
  18                                                 // Slave
  19          #define  SPI_READ          0x08        // Send a byte from the Slave to the
  20                                                 // Master
  21          #define  SPI_READ_BUFFER   0x32        // Send a series of bytes from the Slave
  22                                                 // to the Master
  23          #define  ERROR_OCCURRED    0x40        // Indicator for the Slave to tell the
  24                                                 // Master an error occurred
  25          
  26          // Value used to sample accelerometer values
  27          #define  ACCELERO_RESOLUTION    31.2   //In mg/LSB, resolution of accelerometer
  28          #define  DATA_SAMPLE                    20     //Number of values sampled to evaluate rotation speed
  29          
  30          
  31          // Referenced used in the program
  32          sbit LED0 = P2^0;
  33          sbit LED1 = P2^1;
  34          sbit LED2 = P2^2;
  35          sbit LED3 = P2^3;
  36          sbit RED = P2^4;
  37          sbit GREEN = P2^5;
  38          sbit BLUE = P2^6;
  39          //delete below
  40          sbit LED = P3^3;                       // LED='1' means ON
  41          sbit SW2 = P0^7;                          // SW2='0' means switch pressed
  42          
  43          //-----------------------------------------------------------------------------
  44          // 16-bit SFR Definitions for 'F30x
  45          //-----------------------------------------------------------------------------
  46          
  47          sfr16 TMR2RL   = 0xca;                    // Timer2 reload value
  48          sfr16 TMR2     = 0xcc;                    // Timer2 counter
  49          
  50          //-----------------------------------------------------------------------------
  51          // Global Variables used in SPI communication
  52          //-----------------------------------------------------------------------------
  53          
  54          unsigned char SPI_Data = 0xA5;
  55          
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/29/2015 23:27:48 PAGE 2   

  56          unsigned char SPI_Data_Array[MAX_BUFFER_SIZE] = {0};
  57          
  58          bit Error_Flag = 0;
  59          
  60          unsigned char Command = 0x00;
  61          
  62          //-----------------------------------------------------------------------------
  63          // Function Prototypes
  64          //-----------------------------------------------------------------------------
  65          
  66          void Oscillator_Init (void);
  67          void Port_Init (void);
  68          void SPI0_Init (void);
  69          void Accelerometer_Init (void);
  70          void Init_Device (void);
  71          void Timer2_Init (int);
  72          void Timer2_ISR (void);
  73          void UART0_Init (void);
  74          void Delay(void);
  75          void sampleAcceleration (void);
  76          
  77          void SPI_Byte_Write (unsigned char);
  78          void SPI_Byte_Read (unsigned char);
  79          void SPI_Array_Read (unsigned char);
  80          
  81          //-----------------------------------------------------------------------------
  82          // main() Routine
  83          //-----------------------------------------------------------------------------
  84          void main (void)
  85          {
  86   1         long accel[2]={0,0};
  87   1         int speed[DATA_SAMPLE]={0};
  88   1         long moyenne;
  89   1         int iter=0;
  90   1         unsigned long norme;
  91   1         unsigned long count=0;
  92   1      
  93   1      
  94   1              Init_Device ();                     // Initializes hardware peripherals
  95   1      
  96   1              LED = 0;
  97   1              //enable leds and set them green
  98   1              LED0 = 1;
  99   1              LED1 = 1;
 100   1              LED2 = 1;
 101   1              LED3 = 1;
 102   1              RED=0;
 103   1              BLUE=0;
 104   1              GREEN=1;
 105   1      
 106   1         // TEST BEGIN --------------------------------------------------------------
 107   1      
 108   1         
 109   1      
 110   1      
 111   1      
 112   1         
 113   1      
 114   1         while (1) {                            // spin forever
 115   2              // Read the array of xyz of acceleration
 116   2               SPI_Array_Read (0x32);
 117   2      
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/29/2015 23:27:48 PAGE 3   

 118   2      
 119   2              //The ADXL345 gives 10-bit acceleration values, but they are stored as bytes
 120   2              // (8-bits). To get the full value, two bytes must be combined for each axis.
 121   2        //The Y value is stored in values[2] and values[3].
 122   2               accel[0] = ((int)SPI_Data_Array[3]<<8)|(int)SPI_Data_Array[2];
 123   2        //The Z value is stored in values[4] and values[5].
 124   2               accel[1] = ((int)SPI_Data_Array[5]<<8)|(int)SPI_Data_Array[4];
 125   2              //Convert those values in mg (mg=10^-3*gravity)
 126   2               accel[0]=(int)(accel[0]*ACCELERO_RESOLUTION);
 127   2               accel[1]=(int)(accel[1]*ACCELERO_RESOLUTION);
 128   2      
 129   2               speed[iter]=(int)accel[1];
 130   2               
 131   2               iter=iter+1;
 132   2               if(iter==DATA_SAMPLE)
 133   2               {
 134   3                      for (count = 0; count < DATA_SAMPLE; count++)
 135   3                      {
 136   4                              moyenne+=(long)abs(speed[count]);
 137   4                      }
 138   3                      moyenne/=DATA_SAMPLE;
 139   3                      //convert medium strength momentum to a timer 2 reload value
 140   3                      norme=sqrt(accel[0]*accel[0]+accel[1]*accel[1]);
 141   3                      iter=0;
 142   3                      //display value on bluetooth
 143   3                      printf("y= %ld mg, ",accel[0]);
 144   3                      printf("z= %ld mg, ",accel[1]);
 145   3                      printf("norme= %lu mg \n",norme);
 146   3                      printf("moyZ= %ld rad/s\n",moyenne);
 147   3               }
 148   2               Delay();
 149   2         }
 150   1         
 151   1      }
 152          
 153          /*Initialize system clock*/
 154          void Oscillator_Init (void)
 155          {
 156   1              OSCICN = 0xC3;                     // Set the internal oscillator to 24.5 MHz
 157   1              RSTSRC = 0x04;                     // Enable missing clock detector
 158   1      }
 159          
 160          /*Select I/O ports functions*/
 161          void PORT_Init (void)
 162          {
 163   1               // set TxD (P0.4) as push-pull & RxD as open-drain for bluetooth serial communication
 164   1              P0MDOUT |= 0x10;  
 165   1      
 166   1              // Make SCK, MOSI, and NSS push-pull for SPIO communication                    
 167   1         P1MDOUT = 0x0D; 
 168   1               
 169   1         // Make color select push-pull and LED select open drain for LED control System              
 170   1         P2MDOUT = 0x0F0; 
 171   1            
 172   1         //to be deleted                 
 173   1         P3MDOUT = 0x08;                     // Make the LED push-pull
 174   1      
 175   1              //enable uart (bluetooth) and spi (accelerometer)
 176   1              XBR0=0x03;           
 177   1              XBR1=0x40; 
 178   1               
 179   1              //Translate SPI to port 1
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/29/2015 23:27:48 PAGE 4   

 180   1              P0SKIP=0xCF;                  
 181   1      }
 182          
 183          /*Apply settings for the SPI accelerometer communication*/
 184          void SPI0_Init()
 185          {
 186   1         SPI0CFG   = 0x70;                   // Enable the SPI as a Master CKPHA = '1', CKPOL = '1'
 187   1         SPI0CN    = 0x09;                   // 4-wire Single Master, SPI enabled
 188   1         SPI0CKR   = (SYSCLK/(2*SPI_CLOCK))-1; // SPI clock frequency equation from the datasheet
 189   1         ESPI0 = 1;                          // Enable SPI interrupts
 190   1      
 191   1      }
 192          
 193          
 194          /*Send all the information to launch the accelerometer throught SPI*/
 195          void Accelerometer_Init (){
 196   1              
 197   1              SPI_Byte_Read (0x00);
 198   1              // SPI_Data should now be set to 0xE5 if everything is fine
 199   1      
 200   1         //We set the accelerometer on 4-wire mode SPI, with a range of +/-16g
 201   1         //with a resolution of 10bits
 202   1         SPI_Data = 0x03; 
 203   1         //write in DATA_FORMAT register
 204   1         SPI_Byte_Write (0x31);
 205   1              
 206   1              //Accelerometer mode bypass & interruption INT2 set
 207   1              SPI_Data = 0x20;
 208   1              //write in FIFO_CTL register
 209   1         SPI_Byte_Write (0x38);
 210   1      
 211   1         //switch on normal power mode
 212   1              SPI_Data = 0x0A;
 213   1              //BW_RATE register
 214   1         SPI_Byte_Write (0x2C);
 215   1         
 216   1         //launch measurement
 217   1         SPI_Data = 0x08;
 218   1         // POWER_CTL register
 219   1         SPI_Byte_Write (0x2D);
 220   1      
 221   1              //Calibration correcting z axis constant measurement offset 
 222   1         SPI_Data = 0x07;
 223   1         //OFSZ register
 224   1         SPI_Byte_Write (0x20);
 225   1      
 226   1      }
 227          
 228          /* Init each parts of our system*/
 229          void Init_Device (void)
 230          {
 231   1         PCA0MD &= ~0x40;                    // Disable the Watchdog Timer
 232   1         Oscillator_Init ();
 233   1         Port_Init ();
 234   1         SPI0_Init ();
 235   1         Timer2_Init (0xFFF0);              // Init Timer2
 236   1         UART0_Init();
 237   1         EA = 1;            // Enable global interrupts
 238   1         NSSMD0 = 1;  //Disable communication on SPI bus
 239   1         Accelerometer_Init ();
 240   1      }
 241          
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/29/2015 23:27:48 PAGE 5   

 242          /*SPI communication interruption from the example*/
 243          void SPI_ISR (void) interrupt 6
 244          {
 245   1         static unsigned char array_index = 0;
 246   1         static char state = 0;
 247   1      
 248   1         if (WCOL == 1)
 249   1         {
 250   2            // Write collision occurred
 251   2            WCOL = 0;                        // Clear the write collision flag
 252   2      
 253   2            Error_Flag = 1;
 254   2         }
 255   1         else
 256   1         {
 257   2            if (SPI0DAT == ERROR_OCCURRED)
 258   2            {
 259   3               // This example recognizes when an error occurs, but does not include
 260   3               // any error handling.  The transfer can be aborted or rescheduled,
 261   3               // if desired.
 262   3               Error_Flag = 1;
 263   3            }
 264   2      
 265   2            // When the Master enters the ISR, the SPIF flag should be set from
 266   2            // sending the Command byte.  This ISR handles the remaining steps of the
 267   2            // SPI transfer process.
 268   2            // <state> == 0: writing or reading 1 byte of data
 269   2            // <state> == 1: for READ commands (first time, only a dummy byte is
 270   2            //               sent but the second time, the data must be read from
 271   2            //               SPI0DAT)
 272   2            // <state> == 2: NSS = 1 to end the transfer, final byte read
 273   2            //
 274   2            // Note: SPI_WRITE_BUFFER is not handled here because it's done in
 275   2            // polled mode
 276   2            if (state == 0)
 277   2            {
 278   3               switch (Command)
 279   3               {
 280   4      
 281   4                  case SPI_WRITE:
 282   4                     SPI0DAT = SPI_Data;
 283   4      
 284   4                     state = 2;              // Advance to the final state (only
 285   4                                             // writing one byte)
 286   4      
 287   4                     break;
 288   4      
 289   4                  case SPI_READ:
 290   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 291   4                                             // send the data
 292   4      
 293   4                     state = 2;              // Advance to the final state (only
 294   4                                             // reading one byte)
 295   4      
 296   4                     break;
 297   4      
 298   4                  case SPI_READ_BUFFER:
 299   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 300   4                                             // start sending the data
 301   4      
 302   4                     state = 1;              // Advance to the next state where the
 303   4                                             // data can be received
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/29/2015 23:27:48 PAGE 6   

 304   4                                             // The data from the slave is not
 305   4                                             // available until after the second
 306   4                                             // transfer is completed.
 307   4                                             // The dummy byte allows the slave to
 308   4                                             // send data, since the Master controls
 309   4                                             // SCK.
 310   4      
 311   4                     break;
 312   4      
 313   4                  default:
 314   4                     state = 2;              // Any errors in the Command parsing
 315   4                                             // should go to state 2 where NSSMD0
 316   4                                             // is de-asserted
 317   4               }
 318   3            }
 319   2            else if (state == 1)             // This state is for READ_ARRAY
 320   2            {                                // commands where the data must be read
 321   3                                             // after the first dummy byte is sent
 322   3               switch (Command)
 323   3               {
 324   4                  case SPI_READ_BUFFER:
 325   4                     SPI_Data_Array[array_index] = SPI0DAT;
 326   4                     SPI0DAT = 0xFF;
 327   4      
 328   4                     array_index++;
 329   4      
 330   4                     if (array_index == (MAX_BUFFER_SIZE-1))
 331   4                     {
 332   5                        state = 2;
 333   5                     }
 334   4      
 335   4                     break;
 336   4                  default:
 337   4                     state = 2;              // Any errors in the Command parsing
 338   4                                             // should go to state 2 where NSSMD0
 339   4                                             // is de-asserted
 340   4               }
 341   3            }
 342   2            else if (state == 2)
 343   2            {
 344   3               switch (Command)
 345   3               {
 346   4                  case SPI_READ:
 347   4                     SPI_Data = SPI0DAT;     // Read the data from the slave
 348   4      
 349   4                     break;
 350   4      
 351   4                  case SPI_READ_BUFFER:
 352   4                     SPI_Data_Array[array_index] = SPI0DAT; // Read the last data
 353   4                                                            // without sending a
 354   4                                                            // dummy byte
 355   4                                      array_index=0;
 356   4      
 357   4                     break;
 358   4               }
 359   3      
 360   3               NSSMD0 = 1;                   // De-select the Slave
 361   3      
 362   3               state = 0;                    // Reset the state
 363   3            }
 364   2      
 365   2            SPIF = 0;                        // Clear the SPIF flag
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/29/2015 23:27:48 PAGE 7   

 366   2         }
 367   1      }
 368          
 369          
 370          /*Write a specified data on the register of the accelerometer*/
 371          void SPI_Byte_Write (unsigned char addr)
 372          {
 373   1         while (!NSSMD0);                    // Wait until the SPI is free
 374   1         NSSMD0 = 0;
 375   1         Command = SPI_WRITE;
 376   1         SPI0DAT = addr;
 377   1         while (!NSSMD0); 
 378   1              //wait until operation is finished
 379   1         // The rest of this command will be handled by the SPI ISR, which will
 380   1         // trigger when SPIF is set from sending the Command
 381   1      }
 382          
 383          /*Read a specified data on the register of the accelerometer*/
 384          void SPI_Byte_Read (unsigned char addr)
 385          {
 386   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 387   1                                             // it's already busy
 388   1         NSSMD0 = 0;
 389   1         Command = SPI_READ;
 390   1         SPI0DAT = 0x80 | addr;  //Set Read byte and no multiple bytes
 391   1         while (!NSSMD0); 
 392   1              //wait until operation is finished
 393   1         // The rest of this command will be handled by the SPI ISR, which will
 394   1         // trigger when SPIF is set from sending the Command
 395   1      }
 396          
 397          
 398          /*Read an array of data with size MAX_BUFFER_ARRAY and from the specified address*/
 399          void SPI_Array_Read (unsigned char addr)
 400          {
 401   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 402   1                                             // it's already busy
 403   1         NSSMD0 = 0;
 404   1         Command = SPI_READ_BUFFER;
 405   1         SPI0DAT = 0xC0 | addr; //Set Read byte and  multiple bytes
 406   1         while (!NSSMD0); 
 407   1      
 408   1         // The rest of this command will be handled by the SPI ISR, which will
 409   1         // trigger when SPIF is set from sending the Command
 410   1      }
 411          
 412          /*Init timer to launch interruption every n timer rise*/
 413          void Timer2_Init (int n)
 414          {
 415   1                                                // use SYSCLK/12 as timebase
 416   1         CKCON  &= ~0x10;                       // Timer2 clocked based on T2XCLK
 417   1         TMR2CN  = 0x04;                        // Stop Timer2 Clear TF2
 418   1         TMR2RL  = -n;                          // Init reload values
 419   1         ET2 = 1;
 420   1      
 421   1      }
 422          
 423          
 424          //-----------------------------------------------------------------------------
 425          // UART0_Init
 426          //-----------------------------------------------------------------------------
 427          //
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/29/2015 23:27:48 PAGE 8   

 428          
 429          
 430          void UART0_Init()
 431          {
 432   1         //Timer 1 init
 433   1         TH1     = 0x96;                        // débordement à 9600Hz
 434   1         TMOD   |= 0x20;                        // mode2 autoreload
 435   1         CKCON  &= 0xF4;                        // sysclk pour timer1
 436   1         TR1     = 1;                           // timer1 run
 437   1         REN0    = 1;                           // reception autorisée
 438   1         SBUF0   = '\n';                        // pour commencer nouvelle  
 439   1      }
 440          
 441          //-----------------------------------------------------------------------------
 442          // Interrupt Service Routines
 443          //-----------------------------------------------------------------------------
 444          
 445          //-----------------------------------------------------------------------------
 446          // Timer2_ISR
 447          //-----------------------------------------------------------------------------
 448          // This routine changes the state of the LED whenever Timer2 overflows.
 449          //
 450          void Timer2_ISR (void) interrupt 5
 451          {
 452   1         if (~SW2) {
 453   2            LED = 1;
 454   2         }
 455   1         else {
 456   2            LED = ~LED;
 457   2         }
 458   1      
 459   1         TF2H = 0;                              // clear Timer2 interrupt flag
 460   1      }
 461          
 462          //-----------------------------------------------------------------------------
 463          // Delay
 464          //-----------------------------------------------------------------------------
 465          //
 466          // Return Value : None
 467          // Parameters   : None
 468          //
 469          // Delay for little while (used for blinking the LEDs)
 470          //
 471          //-----------------------------------------------------------------------------
 472          void Delay (void)
 473          {
 474   1         unsigned long count;
 475   1      
 476   1         for (count = 20000; count > 0; count--);
 477   1      }
 478          
 479          void sampleAcceleration (void)
 480          {
 481   1      
 482   1      }
 483          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    929    ----
   CONSTANT SIZE    =    105    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/29/2015 23:27:48 PAGE 9   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10      66
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

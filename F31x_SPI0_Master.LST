C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE F31X_SPI0_MASTER
OBJECT MODULE PLACED IN F31x_SPI0_Master.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe F31x_SPI0_Master.c DB OE BR INCDIR(c:\SiLabs\MCU\Inc)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F31x_SPI0_Master.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2006 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          //
   7          // Program Description:
   8          //
   9          // This program configures a C8051F31x as a 4-wire SPI Single Master.
  10          //
  11          // The SPI clock in this example is limited to 500 kHz when used with the
  12          // SPI0_Slave code example.  During a SPI_Read, the slave needs some time to
  13          // interpret the command and write the appropriate data to the SPI0DAT
  14          // register, and the slave no longer has enough time to complete the
  15          // SPI_READ_BUFFER command with a clock greater than 500 kHz.  For faster SPI
  16          // clocks, a dummy byte between the command and the first byte of Read data
  17          // will be required.
  18          //
  19          // This example is intended to be used with the SPI0_Slave example.
  20          //
  21          // Pinout:
  22          //
  23          // P0.0 - SPI SCK    (digital output, push-pull)
  24          // P0.1 - SPI MISO   (digital input, open-drain)
  25          // P0.2 - SPI MOSI   (digital output, push-pull)
  26          // P0.3 - SPI NSS    (digital output, push-pull)
  27          //
  28          // P3.3 - LED        (digital output, push-pull)
  29          //
  30          // all other port pins unused.
  31          //
  32          //
  33          // How To Test:
  34          //
  35          // 1) Download the code to a F310-TB that is connected as above to
  36          //    another device running the SPI0_Slave code.
  37          // 2) Verify the LED pins of jumper J3 are populated.
  38          // 3) Verify J9 and J10 are populated.
  39          // 4) Run the code.
  40          // 5) If the communication passes, the LEDs on both the Master and Slave
  41          //    boards will blink slowly. If it fails, the LEDs will be OFF.
  42          //
  43          //
  44          // Target:         C8051F31x
  45          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  46          // Command Line:   None
  47          //
  48          // Release 1.0
  49          //    -Initial Revision (TP)
  50          //    -12 DEC 2006
  51          //
  52          
  53          //-----------------------------------------------------------------------------
  54          // Includes
  55          //-----------------------------------------------------------------------------
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 2   

  56          
  57          #include <C8051F310.h>                 // SFR declarations
  58          
  59          //-----------------------------------------------------------------------------
  60          // Global Constants
  61          //-----------------------------------------------------------------------------
  62          
  63          #define SYSCLK             24500000    // Internal oscillator frequency in Hz
  64          
  65          #define SPI_CLOCK          500000      // Maximum SPI clock
  66                                                 // The SPI clock is a maximum of 500 kHz
  67                                                 // when this example is used with
  68                                                 // the SPI0_Slave code example.
  69          
  70          #define MAX_BUFFER_SIZE    6           // Maximum buffer Master will send
  71          
  72          // Instruction Set
  73          #define  SLAVE_LED_ON      0x01        // Turn the Slave LED on
  74          #define  SLAVE_LED_OFF     0x02        // Turn the Slave LED off
  75          #define  SPI_WRITE         0x04        // Send a byte from the Master to the
  76                                                 // Slave
  77          #define  SPI_READ          0x08        // Send a byte from the Slave to the
  78                                                 // Master
  79          #define  SPI_WRITE_BUFFER  0x10        // Send a series of bytes from the
  80                                                 // Master to the Slave
  81          #define  SPI_READ_BUFFER   0x32        // Send a series of bytes from the Slave
  82                                                 // to the Master
  83          #define  ERROR_OCCURRED    0x40        // Indicator for the Slave to tell the
  84                                                 // Master an error occurred
  85          
  86          #define  ACCELERO_RESOLUTION    31.2
  87          
  88          sbit LED = P3^3;                       // LED='1' means ON
  89          
  90          
  91          //-----------------------------------------------------------------------------
  92          // Global Variables
  93          //-----------------------------------------------------------------------------
  94          
  95          unsigned char SPI_Data = 0xA5;
  96          
  97          unsigned char SPI_Data_Array[MAX_BUFFER_SIZE] = {0};
  98          
  99          bit Error_Flag = 0;
 100          
 101          unsigned char Command = 0x00;
 102          
 103          //-----------------------------------------------------------------------------
 104          // Function Prototypes
 105          //-----------------------------------------------------------------------------
 106          
 107          void PCA0_Init (void);
 108          void Oscillator_Init (void);
 109          void Port_Init (void);
 110          void SPI0_Init (void);
 111          void Init_Device (void);
 112          
 113          void SPI_Byte_Write (unsigned char addr);
 114          void SPI_Byte_Read (unsigned char addr);
 115          void SPI_Array_Read (unsigned char addr);
 116          
 117          //-----------------------------------------------------------------------------
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 3   

 118          // main() Routine
 119          //-----------------------------------------------------------------------------
 120          void main (void)
 121          {
 122   1         int accel[3]={0,0,0};
 123   1      
 124   1         Init_Device ();                     // Initializes hardware peripherals
 125   1      
 126   1         EA = 1;                             // Enable global interrupts
 127   1      
 128   1         LED = 0;
 129   1      
 130   1         // TEST BEGIN --------------------------------------------------------------
 131   1      
 132   1         
 133   1      
 134   1         NSSMD0 = 1;
 135   1      
 136   1         SPI_Byte_Read (0x00);
 137   1      
 138   1                            // Wait until the Read transfer has
 139   1      
 140   1      
 141   1         SPI_Data = 0x03; //met le bit 6 a 0 sur ladresse 31, indique au gyro qu'on fonctionne en 4wire
 142   1         //& range de +/- 16g et resolution à 10bits
 143   1         // Write a value
 144   1         SPI_Byte_Write (0x31);
 145   1                      // Wait until the Write transfer has
 146   1                                            // finished
 147   1      
 148   1              SPI_Data = 0x20;//Mode bypass & interruption used INT2
 149   1         // Write a value
 150   1         SPI_Byte_Write (0x38);
 151   1                      // Wait until the Write transfer has
 152   1                                            // finished
 153   1              SPI_Data = 0x0A;//bit d4=0 normal power
 154   1         // Write a value
 155   1         SPI_Byte_Write (0x2C);
 156   1                      // Wait until the Write transfer has
 157   1                                            // finished
 158   1                      SPI_Data = 0x08;//measurement mode on
 159   1         // Write a value
 160   1         SPI_Byte_Write (0x2D);
 161   1      
 162   1              // Read the array back from the slave
 163   1         SPI_Array_Read (0x32);
 164   1      
 165   1         // Read the same value back
 166   1      
 167   1              //The ADXL345 gives 10-bit acceleration values, but they are stored as bytes (8-bits). To get the full va
             -lue, two bytes must be combined for each axis.
 168   1        //The X value is stored in values[0] and values[1].
 169   1        accel[0] = ((int)SPI_Data_Array[1]<<8)|(int)SPI_Data_Array[0];
 170   1        //The Y value is stored in values[2] and values[3].
 171   1        accel[1] = ((int)SPI_Data_Array[3]<<8)|(int)SPI_Data_Array[2];
 172   1        //The Z value is stored in values[4] and values[5].
 173   1        accel[2] = ((int)SPI_Data_Array[5]<<8)|(int)SPI_Data_Array[4];
 174   1        accel[0]=(int)(accel[0]*ACCELERO_RESOLUTION);
 175   1        accel[1]=(int)(accel[1]*ACCELERO_RESOLUTION);
 176   1        accel[2]=(int)(accel[2]*ACCELERO_RESOLUTION);
 177   1         
 178   1      
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 4   

 179   1         while(1){;}
 180   1      
 181   1         
 182   1      }
 183          
 184          //-----------------------------------------------------------------------------
 185          // Initialization Subroutines
 186          //-----------------------------------------------------------------------------
 187          
 188          //-----------------------------------------------------------------------------
 189          // PCA0_Init
 190          //-----------------------------------------------------------------------------
 191          //
 192          // Return Value : None
 193          // Parameters   : None
 194          //
 195          // This function disables the watchdog timer.
 196          //
 197          //-----------------------------------------------------------------------------
 198          void PCA0_Init (void)
 199          {
 200   1         PCA0MD &= ~0x40;                    // Disable the Watchdog Timer
 201   1         PCA0MD = 0x00;
 202   1      }
 203          
 204          //-----------------------------------------------------------------------------
 205          // Oscillator_Init
 206          //-----------------------------------------------------------------------------
 207          //
 208          // Return Value : None
 209          // Parameters   : None
 210          //
 211          // This function initializes the system clock to use the internal oscillator
 212          // at 24.5 MHz.
 213          //
 214          //-----------------------------------------------------------------------------
 215          void Oscillator_Init (void)
 216          {
 217   1         OSCICN = 0x83;                      // Set the internal oscillator to
 218   1                                             // 24.5 MHz
 219   1      }
 220          
 221          //-----------------------------------------------------------------------------
 222          // Port_Init
 223          //-----------------------------------------------------------------------------
 224          //
 225          // Return Value : None
 226          // Parameters   : None
 227          //
 228          // This function configures the crossbar and GPIO ports.
 229          //
 230          // P0.0  -  SCK  (SPI0), Push-Pull,  Digital
 231          // P0.1  -  MISO (SPI0), Open-Drain, Digital
 232          // P0.2  -  MOSI (SPI0), Push-Pull,  Digital
 233          // P0.3  -  NSS  (SPI0), Push-Pull,  Digital
 234          //
 235          // P3.3  -  LED,         Push-Pull,  Digital (LED D2 on Target Board)
 236          //
 237          //-----------------------------------------------------------------------------
 238          void PORT_Init (void)
 239          {
 240   1         P1MDOUT = 0x0D;                     // Make SCK, MOSI, and NSS push-pull
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 5   

 241   1         P3MDOUT = 0x08;                     // Make the LED push-pull
 242   1      
 243   1         //XBR0 = 0x02;                        // Enable the SPI on the XBAR
 244   1         //XBR1 = 0x40;                        // Enable the XBAR and weak pull-ups
 245   1      
 246   1         
 247   1              XBR0=0x03;           //enable uart and spi
 248   1              XBR1=0x40;  
 249   1              P0SKIP=0xCF;        //decale de maniere a avoir le spi0 sur port 1          
 250   1      }
 251          
 252          //-----------------------------------------------------------------------------
 253          // SPI0_Init
 254          //-----------------------------------------------------------------------------
 255          //
 256          // Return Value : None
 257          // Parameters   : None
 258          //
 259          // Configures SPI0 to use 4-wire Single Master mode. The SPI timing is
 260          // configured for Mode 0,0 (data centered on first edge of clock phase and
 261          // SCK line low in idle state).
 262          //
 263          //-----------------------------------------------------------------------------
 264          void SPI0_Init()
 265          {
 266   1         SPI0CFG   = 0x70;                   // Enable the SPI as a Master
 267   1                                             // CKPHA = '1', CKPOL = '1'
 268   1         SPI0CN    = 0x09;                   // 4-wire Single Master, SPI enabled
 269   1      
 270   1         // SPI clock frequency equation from the datasheet
 271   1         SPI0CKR   = (SYSCLK/(2*SPI_CLOCK))-1;
 272   1      
 273   1         ESPI0 = 1;                          // Enable SPI interrupts
 274   1      
 275   1      }
 276          
 277          //-----------------------------------------------------------------------------
 278          // Init_Device
 279          //-----------------------------------------------------------------------------
 280          //
 281          // Return Value : None
 282          // Parameters   : None
 283          //
 284          // Calls all device initialization functions.
 285          //
 286          //-----------------------------------------------------------------------------
 287          void Init_Device (void)
 288          {
 289   1         PCA0_Init ();                       // Disable the Watchdog Timer first
 290   1         Oscillator_Init ();
 291   1         Port_Init ();
 292   1         SPI0_Init ();
 293   1      }
 294          
 295          //-----------------------------------------------------------------------------
 296          // Interrupt Service Routines
 297          //-----------------------------------------------------------------------------
 298          
 299          //-----------------------------------------------------------------------------
 300          // SPI_ISR
 301          //-----------------------------------------------------------------------------
 302          //
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 6   

 303          // Handles all error checks and single-byte writes.
 304          //
 305          // Note: SPI_WRITE_ARRAY is not handled by this ISR in order to take
 306          // advantage of double-buffering (checking the TXBMT flag) using polling.
 307          //
 308          //
 309          // Typical Write:
 310          //
 311          //              | 1st sent | 2nd sent | 3rd sent |   ...    | last sent |
 312          //              ---------------------------------------------------------
 313          //  Master NSSv | Command  |   Data1  |   Data2  |   ...    |   DataN   |  NSS^
 314          //  Slave       |   N/A    |    N/A   |    N/A   |   ...    |    N/A    |
 315          //
 316          // Typical Read:
 317          //
 318          //              | 1st sent | 2nd sent | 3rd sent |   ...    | last sent |
 319          //              ---------------------------------------------------------
 320          //  Master NSSv | Command  |   dummy  |   dummy  |   ...    |   dummy   |  NSS^
 321          //  Slave       |   N/A    |   Data1  |   Data2  |   ...    |   DataN   |
 322          //-----------------------------------------------------------------------------
 323          void SPI_ISR (void) interrupt 6
 324          {
 325   1         static unsigned char array_index = 0;
 326   1         static char state = 0;
 327   1      
 328   1         if (WCOL == 1)
 329   1         {
 330   2            // Write collision occurred
 331   2            WCOL = 0;                        // Clear the write collision flag
 332   2      
 333   2            Error_Flag = 1;
 334   2         }
 335   1         else
 336   1         {
 337   2            if (SPI0DAT == ERROR_OCCURRED)
 338   2            {
 339   3               // This example recognizes when an error occurs, but does not include
 340   3               // any error handling.  The transfer can be aborted or rescheduled,
 341   3               // if desired.
 342   3               Error_Flag = 1;
 343   3            }
 344   2      
 345   2            // When the Master enters the ISR, the SPIF flag should be set from
 346   2            // sending the Command byte.  This ISR handles the remaining steps of the
 347   2            // SPI transfer process.
 348   2            // <state> == 0: writing or reading 1 byte of data
 349   2            // <state> == 1: for READ commands (first time, only a dummy byte is
 350   2            //               sent but the second time, the data must be read from
 351   2            //               SPI0DAT)
 352   2            // <state> == 2: NSS = 1 to end the transfer, final byte read
 353   2            //
 354   2            // Note: SPI_WRITE_BUFFER is not handled here because it's done in
 355   2            // polled mode
 356   2            if (state == 0)
 357   2            {
 358   3               switch (Command)
 359   3               {
 360   4                  case SLAVE_LED_ON:
 361   4                  case SLAVE_LED_OFF:
 362   4                     NSSMD0 = 1;             // Release the slave (not expecting
 363   4                                             // data back)
 364   4      
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 7   

 365   4                     break;
 366   4      
 367   4                  case SPI_WRITE:
 368   4                     SPI0DAT = SPI_Data;
 369   4      
 370   4                     state = 2;              // Advance to the final state (only
 371   4                                             // writing one byte)
 372   4      
 373   4                     break;
 374   4      
 375   4                  case SPI_READ:
 376   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 377   4                                             // send the data
 378   4      
 379   4                     state = 2;              // Advance to the final state (only
 380   4                                             // reading one byte)
 381   4      
 382   4                     break;
 383   4      
 384   4                  case SPI_READ_BUFFER:
 385   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 386   4                                             // start sending the data
 387   4      
 388   4                     state = 1;              // Advance to the next state where the
 389   4                                             // data can be received
 390   4                                             // The data from the slave is not
 391   4                                             // available until after the second
 392   4                                             // transfer is completed.
 393   4                                             // The dummy byte allows the slave to
 394   4                                             // send data, since the Master controls
 395   4                                             // SCK.
 396   4      
 397   4                     break;
 398   4      
 399   4                  default:
 400   4                     state = 2;              // Any errors in the Command parsing
 401   4                                             // should go to state 2 where NSSMD0
 402   4                                             // is de-asserted
 403   4               }
 404   3            }
 405   2            else if (state == 1)             // This state is for READ_ARRAY
 406   2            {                                // commands where the data must be read
 407   3                                             // after the first dummy byte is sent
 408   3               switch (Command)
 409   3               {
 410   4                  case SPI_READ_BUFFER:
 411   4                     SPI_Data_Array[array_index] = SPI0DAT;
 412   4                     SPI0DAT = 0xFF;
 413   4      
 414   4                     array_index++;
 415   4      
 416   4                     if (array_index == (MAX_BUFFER_SIZE-1))
 417   4                     {
 418   5                        state = 2;
 419   5                     }
 420   4      
 421   4                     break;
 422   4                  default:
 423   4                     state = 2;              // Any errors in the Command parsing
 424   4                                             // should go to state 2 where NSSMD0
 425   4                                             // is de-asserted
 426   4               }
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 8   

 427   3            }
 428   2            else if (state == 2)
 429   2            {
 430   3               switch (Command)
 431   3               {
 432   4                  case SPI_READ:
 433   4                     SPI_Data = SPI0DAT;     // Read the data from the slave
 434   4      
 435   4                     break;
 436   4      
 437   4                  case SPI_READ_BUFFER:
 438   4                     SPI_Data_Array[array_index] = SPI0DAT; // Read the last data
 439   4                                                            // without sending a
 440   4                                                            // dummy byte
 441   4      
 442   4                     break;
 443   4               }
 444   3      
 445   3               NSSMD0 = 1;                   // De-select the Slave
 446   3      
 447   3               state = 0;                    // Reset the state
 448   3            }
 449   2      
 450   2            SPIF = 0;                        // Clear the SPIF flag
 451   2         }
 452   1      }
 453          
 454          
 455          
 456          //-----------------------------------------------------------------------------
 457          // SPI_Byte_Write
 458          //-----------------------------------------------------------------------------
 459          //
 460          // Return Value : None
 461          // Parameters   : None
 462          //
 463          // Note: SPI_Data must contain the data to be sent before calling this
 464          // function.
 465          //
 466          // Writes a single byte to the SPI Slave.  The slave does not respond to this
 467          // command, so the command consists of:
 468          //
 469          // Command = SPI_WRITE
 470          // Length = 1 byte of command, 1 byte of data
 471          //
 472          //-----------------------------------------------------------------------------
 473          void SPI_Byte_Write (unsigned char addr)
 474          {
 475   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 476   1                                             // it's already busy
 477   1      
 478   1         NSSMD0 = 0;
 479   1      
 480   1         Command = SPI_WRITE;
 481   1      
 482   1         SPI0DAT = addr;
 483   1      
 484   1         while (!NSSMD0); 
 485   1      
 486   1         // The rest of this command will be handled by the SPI ISR, which will
 487   1         // trigger when SPIF is set from sending the Command
 488   1      }
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 9   

 489          
 490          //-----------------------------------------------------------------------------
 491          // SPI_Byte_Read
 492          //-----------------------------------------------------------------------------
 493          //
 494          // Return Value : None
 495          // Parameters   : None
 496          //
 497          // Note: SPI_Data will contain the data received after calling this function.
 498          //
 499          // Reads a single byte from the SPI Slave.  The command consists of:
 500          //
 501          // Command = SPI_READ
 502          // Length = 1 byte of command, 1 byte of data
 503          //
 504          //-----------------------------------------------------------------------------
 505          void SPI_Byte_Read (unsigned char addr)
 506          {
 507   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 508   1                                             // it's already busy
 509   1      
 510   1         NSSMD0 = 0;
 511   1      
 512   1         Command = SPI_READ;
 513   1      
 514   1         SPI0DAT = 0x80 | addr;
 515   1      
 516   1         while (!NSSMD0); 
 517   1      
 518   1         // The rest of this command will be handled by the SPI ISR, which will
 519   1         // trigger when SPIF is set from sending the Command
 520   1      }
 521          
 522          
 523          //-----------------------------------------------------------------------------
 524          // SPI_Array_Read
 525          //-----------------------------------------------------------------------------
 526          //
 527          // Return Value : None
 528          // Parameters   : None
 529          //
 530          // Note: SPI_Data_Array will contain the data received after calling this
 531          // function.
 532          //
 533          // Reads a single byte from the SPI Slave.  The command consists of:
 534          //
 535          // Command = SPI_READ_BUFFER
 536          // Length = 1 byte of command, MAX_BUFFER_SIZE bytes of data
 537          //
 538          //-----------------------------------------------------------------------------
 539          void SPI_Array_Read (unsigned char addr)
 540          {
 541   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 542   1                                             // it's already busy
 543   1      
 544   1         NSSMD0 = 0;
 545   1      
 546   1         Command = SPI_READ_BUFFER;
 547   1      
 548   1         SPI0DAT = 0xC0 | addr;
 549   1      
 550   1         while (!NSSMD0); 
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 22:20:19 PAGE 10  

 551   1      
 552   1         // The rest of this command will be handled by the SPI ISR, which will
 553   1         // trigger when SPIF is set from sending the Command
 554   1      }
 555          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    426    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     01/07/2016 16:22:02 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE F31X_SPI0_MASTER
OBJECT MODULE PLACED IN F31x_SPI0_Master.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe F31x_SPI0_Master.c DB OE BR INCDIR(c:\SiLabs\MCU\Inc)

line level    source

   1          
   2          #include <C8051F310.h>               
   3          #include "stdio.h"
   4          #include "math.h"
   5          
   6          //-----------------------------------------------------------------------------
   7          // Global Constants
   8          //-----------------------------------------------------------------------------
   9          
  10          #define SYSCLK             24500000    // Internal oscillator frequency in Hz
  11          
  12          #define SPI_CLOCK          5000000      // Maximum SPI clock
  13          
  14          #define MAX_BUFFER_SIZE    6           // Maximum buffer Master SPI will receive
  15          
  16          // Instruction Set for SPI
  17          #define  SPI_WRITE         0x04        // Send a byte from the Master to the
  18                                                 // Slave
  19          #define  SPI_READ          0x08        // Send a byte from the Slave to the
  20                                                 // Master
  21          #define  SPI_READ_BUFFER   0x32        // Send a series of bytes from the Slave
  22                                                 // to the Master
  23          #define  ERROR_OCCURRED    0x40        // Indicator for the Slave to tell the
  24                                                 // Master an error occurred
  25          
  26          // Value used to sample accelerometer values
  27          #define  ACCELERO_RESOLUTION    31.2   //In mg/LSB, resolution of accelerometer
  28          #define  DATA_SAMPLE                    250     //Number of values sampled to evaluate rotation speed
  29          #define  RADIUS                                 0.047     //meter
  30          #define  GRAVITY                                9.81     //m/s^2
  31          #define  PI                                     3.14     
  32          #define  WHEELSECTORS                   80
  33          
  34          // Referenced used in the program
  35          sbit LED0 = P2^0;
  36          sbit LED1 = P2^1;
  37          sbit LED2 = P2^2;
  38          sbit LED3 = P2^3;
  39          sbit LED4 = P2^4;
  40          sbit RED = P2^5;
  41          sbit GREEN = P2^6;
  42          sbit BLUE = P2^7;
  43          //delete below
  44          sbit LED = P3^3;                       // LED='1' means ON
  45          sbit SW2 = P0^7;                          // SW2='0' means switch pressed
  46          
  47          //-----------------------------------------------------------------------------
  48          // 16-bit SFR Definitions for 'F30x
  49          //-----------------------------------------------------------------------------
  50          
  51          sfr16 TMR2RL   = 0xca;                    // Timer2 reload value
  52          sfr16 TMR2     = 0xcc;                    // Timer2 counter
  53          
  54          //-----------------------------------------------------------------------------
  55          // Global Variables used in SPI communication
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     01/07/2016 16:22:02 PAGE 2   

  56          //-----------------------------------------------------------------------------
  57          
  58          unsigned char SPI_Data = 0xA5;
  59          
  60          unsigned char SPI_Data_Array[MAX_BUFFER_SIZE] = {0};
  61          
  62          bit Error_Flag = 0;
  63          
  64          unsigned char Command = 0x00;
  65          
  66          
  67             unsigned long moyenne;
  68             int iter=0;
  69             unsigned int counter=0;
  70          
  71          //-----------------------------------------------------------------------------
  72          // Function Prototypes
  73          //-----------------------------------------------------------------------------
  74          
  75          void Oscillator_Init (void);
  76          void Port_Init (void);
  77          void SPI0_Init (void);
  78          void Accelerometer_Init (void);
  79          void Init_Device (void);
  80          void Timer2_Init (int);
  81          void Timer2_ISR (void);
  82          void UART0_Init (void);
  83          void Delay(void);
  84          void sampleAcceleration (void);
  85          
  86          void SPI_Byte_Write (unsigned char);
  87          void SPI_Byte_Read (unsigned char);
  88          void SPI_Array_Read (unsigned char);
  89          
  90          //-----------------------------------------------------------------------------
  91          // main() Routine
  92          //-----------------------------------------------------------------------------
  93          void main (void)
  94          {
  95   1         unsigned char inputcharacter;       // Used to store character from UART
  96   1      
  97   1      
  98   1              Init_Device ();                     // Initializes hardware peripherals
  99   1      
 100   1              LED = 0;
 101   1              //enable leds and set them green
 102   1              LED0 = 0;
 103   1              LED1 = 0;
 104   1              LED2 = 0;
 105   1              LED3 = 0;
 106   1              LED4 = 0;
 107   1              RED=0;
 108   1              BLUE=0;
 109   1              GREEN=0;
 110   1      
 111   1      
 112   1         while (1) {
 113   2              sampleAcceleration ();
 114   2               Delay();
 115   2               //printf ("\nEnter character: ");
 116   2           // inputcharacter = getchar ();
 117   2           // printf ("\nCharacter entered : %c",inputcharacter);
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     01/07/2016 16:22:02 PAGE 3   

 118   2          //  printf ("\n      Value in Hex: %bx",inputcharacter);
 119   2         }
 120   1         
 121   1      }
*** WARNING C280 IN LINE 95 OF F31x_SPI0_Master.c: 'inputcharacter': unreferenced local variable
 122          
 123          /*Initialize system clock*/
 124          void Oscillator_Init (void)
 125          {
 126   1              OSCICN = 0xC3;                     // Set the internal oscillator to 24.5 MHz
 127   1              RSTSRC = 0x04;                     // Enable missing clock detector
 128   1      }
 129          
 130          /*Select I/O ports functions*/
 131          void PORT_Init (void)
 132          {
 133   1               // set TxD (P0.4) as push-pull & RxD as open-drain for bluetooth serial communication
 134   1              P0MDOUT |= 0x10;  
 135   1      
 136   1              // Make SCK, MOSI, and NSS push-pull for SPIO communication                    
 137   1         P1MDOUT = 0x0D; 
 138   1               
 139   1         // Make color select LED select open drain for LED control System              
 140   1         P2MDOUT = 0xF0; 
 141   1            
 142   1         //to be deleted                 
 143   1         P3MDOUT = 0x08;                     // Make the LED push-pull
 144   1      
 145   1              //enable uart (bluetooth) and spi (accelerometer)
 146   1              XBR0=0x03;           
 147   1              XBR1=0x40; 
 148   1               
 149   1              //Translate SPI to port 1
 150   1              P0SKIP=0xCF;                  
 151   1      }
 152          
 153          /*Apply settings for the SPI accelerometer communication*/
 154          void SPI0_Init()
 155          {
 156   1         SPI0CFG   = 0x70;                   // Enable the SPI as a Master CKPHA = '1', CKPOL = '1'
 157   1         SPI0CN    = 0x09;                   // 4-wire Single Master, SPI enabled
 158   1         SPI0CKR   = (SYSCLK/(2*SPI_CLOCK))-1; // SPI clock frequency equation from the datasheet
 159   1         ESPI0 = 1;                          // Enable SPI interrupts
 160   1      
 161   1      }
 162          
 163          
 164          /*Send all the information to launch the accelerometer throught SPI*/
 165          void Accelerometer_Init (){
 166   1              
 167   1              SPI_Byte_Read (0x00);
 168   1              // SPI_Data should now be set to 0xE5 if everything is fine
 169   1      
 170   1         //We set the accelerometer on 4-wire mode SPI, with a range of +/-16g
 171   1         //with a resolution of 10bits
 172   1         SPI_Data = 0x03; 
 173   1         //write in DATA_FORMAT register
 174   1         SPI_Byte_Write (0x31);
 175   1              
 176   1              //Accelerometer mode bypass & interruption INT2 set
 177   1              SPI_Data = 0x20;
 178   1              //write in FIFO_CTL register
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     01/07/2016 16:22:02 PAGE 4   

 179   1         SPI_Byte_Write (0x38);
 180   1      
 181   1         //switch on normal power mode
 182   1              SPI_Data = 0x0A;
 183   1              //BW_RATE register
 184   1         SPI_Byte_Write (0x2C);
 185   1         
 186   1         //launch measurement
 187   1         SPI_Data = 0x08;
 188   1         // POWER_CTL register
 189   1         SPI_Byte_Write (0x2D);
 190   1      
 191   1              //Calibration correcting z axis constant measurement offset 
 192   1         SPI_Data = 0x07;
 193   1         //OFSZ register
 194   1         SPI_Byte_Write (0x20);
 195   1      
 196   1      }
 197          
 198          /* Init each parts of our system*/
 199          void Init_Device (void)
 200          {
 201   1         PCA0MD &= ~0x40;                    // Disable the Watchdog Timer
 202   1         Oscillator_Init ();
 203   1         Port_Init ();
 204   1         SPI0_Init ();
 205   1         Timer2_Init (0x7FFF);              // Init Timer2
 206   1         UART0_Init();
 207   1         EA = 1;            // Enable global interrupts
 208   1         NSSMD0 = 1;  //Disable communication on SPI bus
 209   1         Accelerometer_Init ();
 210   1      }
 211          
 212          /*SPI communication interruption from the example*/
 213          void SPI_ISR (void) interrupt 6
 214          {
 215   1         static unsigned char array_index = 0;
 216   1         static char state = 0;
 217   1      
 218   1         if (WCOL == 1)
 219   1         {
 220   2            // Write collision occurred
 221   2            WCOL = 0;                        // Clear the write collision flag
 222   2      
 223   2            Error_Flag = 1;
 224   2         }
 225   1         else
 226   1         {
 227   2            if (SPI0DAT == ERROR_OCCURRED)
 228   2            {
 229   3               // This example recognizes when an error occurs, but does not include
 230   3               // any error handling.  The transfer can be aborted or rescheduled,
 231   3               // if desired.
 232   3               Error_Flag = 1;
 233   3            }
 234   2      
 235   2            // When the Master enters the ISR, the SPIF flag should be set from
 236   2            // sending the Command byte.  This ISR handles the remaining steps of the
 237   2            // SPI transfer process.
 238   2            // <state> == 0: writing or reading 1 byte of data
 239   2            // <state> == 1: for READ commands (first time, only a dummy byte is
 240   2            //               sent but the second time, the data must be read from
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     01/07/2016 16:22:02 PAGE 5   

 241   2            //               SPI0DAT)
 242   2            // <state> == 2: NSS = 1 to end the transfer, final byte read
 243   2            //
 244   2            // Note: SPI_WRITE_BUFFER is not handled here because it's done in
 245   2            // polled mode
 246   2            if (state == 0)
 247   2            {
 248   3               switch (Command)
 249   3               {
 250   4      
 251   4                  case SPI_WRITE:
 252   4                     SPI0DAT = SPI_Data;
 253   4      
 254   4                     state = 2;              // Advance to the final state (only
 255   4                                             // writing one byte)
 256   4      
 257   4                     break;
 258   4      
 259   4                  case SPI_READ:
 260   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 261   4                                             // send the data
 262   4      
 263   4                     state = 2;              // Advance to the final state (only
 264   4                                             // reading one byte)
 265   4      
 266   4                     break;
 267   4      
 268   4                  case SPI_READ_BUFFER:
 269   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 270   4                                             // start sending the data
 271   4      
 272   4                     state = 1;              // Advance to the next state where the
 273   4                                             // data can be received
 274   4                                             // The data from the slave is not
 275   4                                             // available until after the second
 276   4                                             // transfer is completed.
 277   4                                             // The dummy byte allows the slave to
 278   4                                             // send data, since the Master controls
 279   4                                             // SCK.
 280   4      
 281   4                     break;
 282   4      
 283   4                  default:
 284   4                     state = 2;              // Any errors in the Command parsing
 285   4                                             // should go to state 2 where NSSMD0
 286   4                                             // is de-asserted
 287   4               }
 288   3            }
 289   2            else if (state == 1)             // This state is for READ_ARRAY
 290   2            {                                // commands where the data must be read
 291   3                                             // after the first dummy byte is sent
 292   3               switch (Command)
 293   3               {
 294   4                  case SPI_READ_BUFFER:
 295   4                     SPI_Data_Array[array_index] = SPI0DAT;
 296   4                     SPI0DAT = 0xFF;
 297   4      
 298   4                     array_index++;
 299   4      
 300   4                     if (array_index == (MAX_BUFFER_SIZE-1))
 301   4                     {
 302   5                        state = 2;
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     01/07/2016 16:22:02 PAGE 6   

 303   5                     }
 304   4      
 305   4                     break;
 306   4                  default:
 307   4                     state = 2;              // Any errors in the Command parsing
 308   4                                             // should go to state 2 where NSSMD0
 309   4                                             // is de-asserted
 310   4               }
 311   3            }
 312   2            else if (state == 2)
 313   2            {
 314   3               switch (Command)
 315   3               {
 316   4                  case SPI_READ:
 317   4                     SPI_Data = SPI0DAT;     // Read the data from the slave
 318   4      
 319   4                     break;
 320   4      
 321   4                  case SPI_READ_BUFFER:
 322   4                     SPI_Data_Array[array_index] = SPI0DAT; // Read the last data
 323   4                                                            // without sending a
 324   4                                                            // dummy byte
 325   4                                      array_index=0;
 326   4      
 327   4                     break;
 328   4               }
 329   3      
 330   3               NSSMD0 = 1;                   // De-select the Slave
 331   3      
 332   3               state = 0;                    // Reset the state
 333   3            }
 334   2      
 335   2            SPIF = 0;                        // Clear the SPIF flag
 336   2         }
 337   1      }
 338          
 339          
 340          /*Write a specified data on the register of the accelerometer*/
 341          void SPI_Byte_Write (unsigned char addr)
 342          {
 343   1         while (!NSSMD0);                    // Wait until the SPI is free
 344   1         NSSMD0 = 0;
 345   1         Command = SPI_WRITE;
 346   1         SPI0DAT = addr;
 347   1         while (!NSSMD0); 
 348   1              //wait until operation is finished
 349   1         // The rest of this command will be handled by the SPI ISR, which will
 350   1         // trigger when SPIF is set from sending the Command
 351   1      }
 352          
 353          /*Read a specified data on the register of the accelerometer*/
 354          void SPI_Byte_Read (unsigned char addr)
 355          {
 356   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 357   1                                             // it's already busy
 358   1         NSSMD0 = 0;
 359   1         Command = SPI_READ;
 360   1         SPI0DAT = 0x80 | addr;  //Set Read byte and no multiple bytes
 361   1         while (!NSSMD0); 
 362   1              //wait until operation is finished
 363   1         // The rest of this command will be handled by the SPI ISR, which will
 364   1         // trigger when SPIF is set from sending the Command
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     01/07/2016 16:22:02 PAGE 7   

 365   1      }
 366          
 367          
 368          /*Read an array of data with size MAX_BUFFER_ARRAY and from the specified address*/
 369          void SPI_Array_Read (unsigned char addr)
 370          {
 371   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 372   1                                             // it's already busy
 373   1         NSSMD0 = 0;
 374   1         Command = SPI_READ_BUFFER;
 375   1         SPI0DAT = 0xC0 | addr; //Set Read byte and  multiple bytes
 376   1         while (!NSSMD0); 
 377   1      
 378   1         // The rest of this command will be handled by the SPI ISR, which will
 379   1         // trigger when SPIF is set from sending the Command
 380   1      }
 381          
 382          /*Init timer to launch interruption every n timer rise*/
 383          void Timer2_Init (int n)
 384          {
 385   1                                                // use SYSCLK/12 as timebase
 386   1         CKCON  &= ~0x10;                       // Timer2 clocked based on T2XCLK
 387   1         TMR2CN  = 0x04;                        // Stop Timer2 Clear TF2
 388   1         TMR2RL  = -n;                          // Init reload values
 389   1         ET2 = 1;
 390   1      
 391   1      }
 392          
 393          
 394          //-----------------------------------------------------------------------------
 395          // UART0_Init
 396          //-----------------------------------------------------------------------------
 397          //
 398          
 399          
 400          void UART0_Init()
 401          {
 402   1         //Timer 1 init
 403   1         TH1     = 0x96;                        // débordement à 9600Hz
 404   1         TMOD   |= 0x20;                        // mode2 autoreload
 405   1         CKCON  &= 0xF4;                        // sysclk pour timer1
 406   1         TR1     = 1;                           // timer1 run
 407   1         REN0    = 1;                           // reception autorisée
 408   1         SBUF0   = '\n';                        // pour commencer nouvelle  
 409   1      }
 410          
 411          //-----------------------------------------------------------------------------
 412          // Interrupt Service Routines
 413          //-----------------------------------------------------------------------------
 414          
 415          //-----------------------------------------------------------------------------
 416          // Timer2_ISR
 417          //-----------------------------------------------------------------------------
 418          // This routine changes the state of the LED whenever Timer2 overflows.
 419          //
 420          void Timer2_ISR (void) interrupt 5
 421          {
 422   1              if(counter==20)
 423   1              {
 424   2      
 425   2                 if (~SW2) {
 426   3                    GREEN = 1;
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     01/07/2016 16:22:02 PAGE 8   

 427   3                 }
 428   2                 else {
 429   3                    GREEN = ~GREEN;
 430   3                 }
 431   2                 counter=0;
 432   2              }
 433   1              counter++;
 434   1         TF2H = 0;                              // clear Timer2 interrupt flag
 435   1      }
 436          
 437          //-----------------------------------------------------------------------------
 438          // Delay
 439          //-----------------------------------------------------------------------------
 440          //
 441          // Return Value : None
 442          // Parameters   : None
 443          //
 444          // Delay for little while (used for blinking the LEDs)
 445          //
 446          //-----------------------------------------------------------------------------
 447          void Delay (void)
 448          {
 449   1         unsigned long count;
 450   1      
 451   1         for (count = 20000; count > 0; count--);
 452   1      }
 453          
 454          void sampleAcceleration (void)
 455          {
 456   1              
 457   1         long accel[2]={0,0};
 458   1         unsigned long norme;
 459   1         unsigned long numerateur, denumerateur;
 460   1         unsigned int count;
 461   1                                          // spin forever
 462   1              // Read the array of xyz of acceleration
 463   1               SPI_Array_Read (0x32);
 464   1      
 465   1      
 466   1              //The ADXL345 gives 10-bit acceleration values, but they are stored as bytes
 467   1              // (8-bits). To get the full value, two bytes must be combined for each axis.
 468   1        //The Y value is stored in values[2] and values[3].
 469   1               accel[0] = ((int)SPI_Data_Array[3]<<8)|(int)SPI_Data_Array[2];
 470   1        //The Z value is stored in values[4] and values[5].
 471   1               accel[1] = ((int)SPI_Data_Array[5]<<8)|(int)SPI_Data_Array[4];
 472   1              //Convert those values in mg (mg=10^-3*gravity)
 473   1               accel[0]=(int)(accel[0]*ACCELERO_RESOLUTION);
 474   1               accel[1]=(int)(accel[1]*ACCELERO_RESOLUTION);
 475   1      
 476   1               moyenne+=(unsigned long)abs((int)accel[1]);
 477   1               iter=iter+1;
 478   1               if(iter==DATA_SAMPLE)
 479   1               {
 480   2                      moyenne/=DATA_SAMPLE;
 481   2                      numerateur=SYSCLK/12;
 482   2                      denumerateur=(sqrt(((moyenne*GRAVITY)/RADIUS)/1000)*WHEELSECTORS)/(2*PI);
 483   2                      count=(unsigned int)(numerateur/denumerateur);
 484   2                      //convert medium strength momentum to a timer 2 reload value
 485   2                      norme=sqrt(accel[0]*accel[0]+accel[1]*accel[1]);
 486   2                      iter=0;
 487   2                      Timer2_Init ((int)count);
 488   2                      //display value on bluetooth
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     01/07/2016 16:22:02 PAGE 9   

 489   2                      printf("y= %ld mg, ",accel[0]);
 490   2                      printf("z= %ld mg, ",accel[1]);
 491   2                      printf("norme= %lu mg \n",norme);
 492   2                      printf("moyZ= %lu rad/s\n",moyenne);
 493   2                      printf("num= %lu \n",numerateur);
 494   2                      printf("denum= %lu \n",denumerateur);
 495   2                      printf("decaltimer= %u \n",count);
 496   2                      moyenne=0;
 497   2               }
 498   1      }
 499          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1030    ----
   CONSTANT SIZE    =    106    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18      27
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

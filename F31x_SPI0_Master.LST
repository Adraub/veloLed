C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE F31X_SPI0_MASTER
OBJECT MODULE PLACED IN F31x_SPI0_Master.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe F31x_SPI0_Master.c DB OE BR INCDIR(c:\SiLabs\MCU\Inc)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F31x_SPI0_Master.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2006 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          //
   7          // Program Description:
   8          //
   9          // This program configures a C8051F31x as a 4-wire SPI Single Master.
  10          //
  11          // The SPI clock in this example is limited to 500 kHz when used with the
  12          // SPI0_Slave code example.  During a SPI_Read, the slave needs some time to
  13          // interpret the command and write the appropriate data to the SPI0DAT
  14          // register, and the slave no longer has enough time to complete the
  15          // SPI_READ_BUFFER command with a clock greater than 500 kHz.  For faster SPI
  16          // clocks, a dummy byte between the command and the first byte of Read data
  17          // will be required.
  18          //
  19          // This example is intended to be used with the SPI0_Slave example.
  20          //
  21          // Pinout:
  22          //
  23          // P0.0 - SPI SCK    (digital output, push-pull)
  24          // P0.1 - SPI MISO   (digital input, open-drain)
  25          // P0.2 - SPI MOSI   (digital output, push-pull)
  26          // P0.3 - SPI NSS    (digital output, push-pull)
  27          //
  28          // P3.3 - LED        (digital output, push-pull)
  29          //
  30          // all other port pins unused.
  31          //
  32          //
  33          // How To Test:
  34          //
  35          // 1) Download the code to a F310-TB that is connected as above to
  36          //    another device running the SPI0_Slave code.
  37          // 2) Verify the LED pins of jumper J3 are populated.
  38          // 3) Verify J9 and J10 are populated.
  39          // 4) Run the code.
  40          // 5) If the communication passes, the LEDs on both the Master and Slave
  41          //    boards will blink slowly. If it fails, the LEDs will be OFF.
  42          //
  43          //
  44          // Target:         C8051F31x
  45          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  46          // Command Line:   None
  47          //
  48          // Release 1.0
  49          //    -Initial Revision (TP)
  50          //    -12 DEC 2006
  51          //
  52          
  53          //-----------------------------------------------------------------------------
  54          // Includes
  55          //-----------------------------------------------------------------------------
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 2   

  56          
  57          #include <C8051F310.h>                 // SFR declarations
  58          
  59          //-----------------------------------------------------------------------------
  60          // Global Constants
  61          //-----------------------------------------------------------------------------
  62          
  63          #define SYSCLK             24500000    // Internal oscillator frequency in Hz
  64          
  65          #define SPI_CLOCK          500000      // Maximum SPI clock
  66                                                 // The SPI clock is a maximum of 500 kHz
  67                                                 // when this example is used with
  68                                                 // the SPI0_Slave code example.
  69          
  70          #define MAX_BUFFER_SIZE    8           // Maximum buffer Master will send
  71          
  72          // Instruction Set
  73          #define  SLAVE_LED_ON      0x01        // Turn the Slave LED on
  74          #define  SLAVE_LED_OFF     0x02        // Turn the Slave LED off
  75          #define  SPI_WRITE         0x04        // Send a byte from the Master to the
  76                                                 // Slave
  77          #define  SPI_READ          0x08        // Send a byte from the Slave to the
  78                                                 // Master
  79          #define  SPI_WRITE_BUFFER  0x10        // Send a series of bytes from the
  80                                                 // Master to the Slave
  81          #define  SPI_READ_BUFFER   0x20        // Send a series of bytes from the Slave
  82                                                 // to the Master
  83          #define  ERROR_OCCURRED    0x40        // Indicator for the Slave to tell the
  84                                                 // Master an error occurred
  85          
  86          sbit LED = P3^3;                       // LED='1' means ON
  87          
  88          unsigned char cmd;
  89          
  90          //-----------------------------------------------------------------------------
  91          // Global Variables
  92          //-----------------------------------------------------------------------------
  93          
  94          unsigned char SPI_Data = 0xA5;
  95          
  96          unsigned char SPI_Data_Array[MAX_BUFFER_SIZE] = {0};
  97          
  98          bit Error_Flag = 0;
  99          
 100          unsigned char Command = 0x00;
 101          
 102          //-----------------------------------------------------------------------------
 103          // Function Prototypes
 104          //-----------------------------------------------------------------------------
 105          
 106          void PCA0_Init (void);
 107          void Oscillator_Init (void);
 108          void Port_Init (void);
 109          void SPI0_Init (void);
 110          void Init_Device (void);
 111          
 112          void SPI_LED_On (void);
 113          void SPI_LED_Off (void);
 114          void SPI_Byte_Write (void);
 115          void SPI_Byte_Read (void);
 116          void SPI_Array_Write (void);
 117          void SPI_Array_Read (void);
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 3   

 118          
 119          void Delay(void);
 120          
 121          //-----------------------------------------------------------------------------
 122          // main() Routine
 123          //-----------------------------------------------------------------------------
 124          void main (void)
 125          {
 126   1         unsigned char test_value = 0x55;
 127   1         unsigned char test_array[MAX_BUFFER_SIZE] = {1,2,3,4,5,6,7,8};
 128   1         unsigned char i;
 129   1      
 130   1         Init_Device ();                     // Initializes hardware peripherals
 131   1      
 132   1         EA = 1;                             // Enable global interrupts
 133   1      
 134   1         LED = 0;
 135   1      
 136   1         // TEST BEGIN --------------------------------------------------------------
 137   1      
 138   1         SPI_Data = test_value;
 139   1      
 140   1         NSSMD0 = 1;
 141   1      
 142   1         cmd = 0x00;
 143   1         SPI_Byte_Read ();
 144   1      
 145   1         while (!NSSMD0);                    // Wait until the Read transfer has
 146   1      
 147   1      cmd =  0; 
 148   1      
 149   1      while (1);
 150   1         // Write a value
 151   1         SPI_Byte_Write ();
 152   1      
 153   1         while (!NSSMD0);                    // Wait until the Write transfer has
 154   1                                             // finished
 155   1      
 156   1         // Read the same value back
 157   1         SPI_Data = 0x00;
 158   1         SPI_Byte_Read ();
 159   1      
 160   1         while (!NSSMD0);                    // Wait until the Read transfer has
 161   1                                             // finished
 162   1      
 163   1         // Check if the sent value and returned value match
 164   1         if (SPI_Data != test_value)
 165   1         {
 166   2            Error_Flag = 1;
 167   2         }
 168   1      
 169   1         // Copy test_array into SPI_Data_Array
 170   1         for (i = 0; i < MAX_BUFFER_SIZE; i++)
 171   1         {
 172   2            SPI_Data_Array[i] = test_array[i];
 173   2         }
 174   1      
 175   1         // Send the array to the slave
 176   1         SPI_Array_Write ();
 177   1      
 178   1         while (!NSSMD0);                    // Wait until the Write transfer has
 179   1                                             // finished
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 4   

 180   1      
 181   1         // Clear SPI_Data_Array for the SPI_Buffer_Read function
 182   1         for (i = 0; i < MAX_BUFFER_SIZE; i++)
 183   1         {
 184   2            SPI_Data_Array[i] = 0;
 185   2         }
 186   1      
 187   1         // Read the array back from the slave
 188   1         SPI_Array_Read ();
 189   1      
 190   1         while (!NSSMD0);                    // Wait until the Read transfer has
 191   1                                             // finished
 192   1      
 193   1         // Check if the received array matches the sent array
 194   1         for (i = 0; i < MAX_BUFFER_SIZE; i++)
 195   1         {
 196   2            if (SPI_Data_Array[i] != test_array[i])
 197   2            {
 198   3               Error_Flag = 1;
 199   3            }
 200   2         }
 201   1      
 202   1         // END OF TEST -------------------------------------------------------------
 203   1      
 204   1         while (1)
 205   1         {
 206   2            // If no error has occurred, blink the LEDs on the Master and Slave
 207   2            // boards
 208   2            if (Error_Flag == 0)
 209   2            {
 210   3               LED = 1;
 211   3      
 212   3               SPI_LED_On ();
 213   3      
 214   3               while (!NSSMD0);
 215   3      
 216   3               Delay ();
 217   3      
 218   3               SPI_LED_Off ();
 219   3      
 220   3               LED = 0;
 221   3      
 222   3               while (!NSSMD0);
 223   3      
 224   3               Delay ();
 225   3            }
 226   2         };
 227   1      }
 228          
 229          //-----------------------------------------------------------------------------
 230          // Initialization Subroutines
 231          //-----------------------------------------------------------------------------
 232          
 233          //-----------------------------------------------------------------------------
 234          // PCA0_Init
 235          //-----------------------------------------------------------------------------
 236          //
 237          // Return Value : None
 238          // Parameters   : None
 239          //
 240          // This function disables the watchdog timer.
 241          //
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 5   

 242          //-----------------------------------------------------------------------------
 243          void PCA0_Init (void)
 244          {
 245   1         PCA0MD &= ~0x40;                    // Disable the Watchdog Timer
 246   1         PCA0MD = 0x00;
 247   1      }
 248          
 249          //-----------------------------------------------------------------------------
 250          // Oscillator_Init
 251          //-----------------------------------------------------------------------------
 252          //
 253          // Return Value : None
 254          // Parameters   : None
 255          //
 256          // This function initializes the system clock to use the internal oscillator
 257          // at 24.5 MHz.
 258          //
 259          //-----------------------------------------------------------------------------
 260          void Oscillator_Init (void)
 261          {
 262   1         OSCICN = 0x83;                      // Set the internal oscillator to
 263   1                                             // 24.5 MHz
 264   1      }
 265          
 266          //-----------------------------------------------------------------------------
 267          // Port_Init
 268          //-----------------------------------------------------------------------------
 269          //
 270          // Return Value : None
 271          // Parameters   : None
 272          //
 273          // This function configures the crossbar and GPIO ports.
 274          //
 275          // P0.0  -  SCK  (SPI0), Push-Pull,  Digital
 276          // P0.1  -  MISO (SPI0), Open-Drain, Digital
 277          // P0.2  -  MOSI (SPI0), Push-Pull,  Digital
 278          // P0.3  -  NSS  (SPI0), Push-Pull,  Digital
 279          //
 280          // P3.3  -  LED,         Push-Pull,  Digital (LED D2 on Target Board)
 281          //
 282          //-----------------------------------------------------------------------------
 283          void PORT_Init (void)
 284          {
 285   1         P1MDOUT = 0x0D;                     // Make SCK, MOSI, and NSS push-pull
 286   1         P3MDOUT = 0x08;                     // Make the LED push-pull
 287   1      
 288   1         //XBR0 = 0x02;                        // Enable the SPI on the XBAR
 289   1         //XBR1 = 0x40;                        // Enable the XBAR and weak pull-ups
 290   1      
 291   1         
 292   1              XBR0=0x03;           //enable uart and spi
 293   1              XBR1=0x40;  
 294   1              P0SKIP=0xCF;        //decale de maniere a avoir le spi0 sur port 1          
 295   1      }
 296          
 297          //-----------------------------------------------------------------------------
 298          // SPI0_Init
 299          //-----------------------------------------------------------------------------
 300          //
 301          // Return Value : None
 302          // Parameters   : None
 303          //
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 6   

 304          // Configures SPI0 to use 4-wire Single Master mode. The SPI timing is
 305          // configured for Mode 0,0 (data centered on first edge of clock phase and
 306          // SCK line low in idle state).
 307          //
 308          //-----------------------------------------------------------------------------
 309          void SPI0_Init()
 310          {
 311   1         SPI0CFG   = 0x70;                   // Enable the SPI as a Master
 312   1                                             // CKPHA = '0', CKPOL = '0'
 313   1         SPI0CN    = 0x09;                   // 4-wire Single Master, SPI enabled
 314   1      
 315   1         // SPI clock frequency equation from the datasheet
 316   1         SPI0CKR   = (SYSCLK/(2*SPI_CLOCK))-1;
 317   1      
 318   1         ESPI0 = 1;                          // Enable SPI interrupts
 319   1      
 320   1      
 321   1      /*
 322   1      SPI0CN|=0x08;   //p181 , NSSMD=1X, 4 wire master mode
 323   1      SPI0CFG|=0x70;  //mode de communication(178), demandé par l'oscillo p15 touche a CKPOL=1, CKPHA=1     MSTE
             -N=1, opere en mode master
 324   1      SPI0CN|=0x01;    //SPIEN=1 spi enabled
 325   1      SPI0CKR=0x01;   //p182 divide clock by 4 in SPI transmission
 326   1      */
 327   1      }
 328          
 329          //-----------------------------------------------------------------------------
 330          // Init_Device
 331          //-----------------------------------------------------------------------------
 332          //
 333          // Return Value : None
 334          // Parameters   : None
 335          //
 336          // Calls all device initialization functions.
 337          //
 338          //-----------------------------------------------------------------------------
 339          void Init_Device (void)
 340          {
 341   1         PCA0_Init ();                       // Disable the Watchdog Timer first
 342   1         Oscillator_Init ();
 343   1         Port_Init ();
 344   1         SPI0_Init ();
 345   1      }
 346          
 347          //-----------------------------------------------------------------------------
 348          // Interrupt Service Routines
 349          //-----------------------------------------------------------------------------
 350          
 351          //-----------------------------------------------------------------------------
 352          // SPI_ISR
 353          //-----------------------------------------------------------------------------
 354          //
 355          // Handles all error checks and single-byte writes.
 356          //
 357          // Note: SPI_WRITE_ARRAY is not handled by this ISR in order to take
 358          // advantage of double-buffering (checking the TXBMT flag) using polling.
 359          //
 360          //
 361          // Typical Write:
 362          //
 363          //              | 1st sent | 2nd sent | 3rd sent |   ...    | last sent |
 364          //              ---------------------------------------------------------
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 7   

 365          //  Master NSSv | Command  |   Data1  |   Data2  |   ...    |   DataN   |  NSS^
 366          //  Slave       |   N/A    |    N/A   |    N/A   |   ...    |    N/A    |
 367          //
 368          // Typical Read:
 369          //
 370          //              | 1st sent | 2nd sent | 3rd sent |   ...    | last sent |
 371          //              ---------------------------------------------------------
 372          //  Master NSSv | Command  |   dummy  |   dummy  |   ...    |   dummy   |  NSS^
 373          //  Slave       |   N/A    |   Data1  |   Data2  |   ...    |   DataN   |
 374          //-----------------------------------------------------------------------------
 375          void SPI_ISR (void) interrupt 6
 376          {
 377   1         static unsigned char array_index = 0;
 378   1         static char state = 0;
 379   1      
 380   1         if (WCOL == 1)
 381   1         {
 382   2            // Write collision occurred
 383   2            WCOL = 0;                        // Clear the write collision flag
 384   2      
 385   2            Error_Flag = 1;
 386   2         }
 387   1         else
 388   1         {
 389   2            if (SPI0DAT == ERROR_OCCURRED)
 390   2            {
 391   3               // This example recognizes when an error occurs, but does not include
 392   3               // any error handling.  The transfer can be aborted or rescheduled,
 393   3               // if desired.
 394   3               Error_Flag = 1;
 395   3            }
 396   2      
 397   2            // When the Master enters the ISR, the SPIF flag should be set from
 398   2            // sending the Command byte.  This ISR handles the remaining steps of the
 399   2            // SPI transfer process.
 400   2            // <state> == 0: writing or reading 1 byte of data
 401   2            // <state> == 1: for READ commands (first time, only a dummy byte is
 402   2            //               sent but the second time, the data must be read from
 403   2            //               SPI0DAT)
 404   2            // <state> == 2: NSS = 1 to end the transfer, final byte read
 405   2            //
 406   2            // Note: SPI_WRITE_BUFFER is not handled here because it's done in
 407   2            // polled mode
 408   2            if (state == 0)
 409   2            {
 410   3               switch (Command)
 411   3               {
 412   4                  case SLAVE_LED_ON:
 413   4                  case SLAVE_LED_OFF:
 414   4                     NSSMD0 = 1;             // Release the slave (not expecting
 415   4                                             // data back)
 416   4      
 417   4                     break;
 418   4      
 419   4                  case SPI_WRITE:
 420   4                     SPI0DAT = SPI_Data;
 421   4      
 422   4                     state = 2;              // Advance to the final state (only
 423   4                                             // writing one byte)
 424   4      
 425   4                     break;
 426   4      
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 8   

 427   4                  case SPI_READ:
 428   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 429   4                                             // send the data
 430   4      
 431   4                     state = 2;              // Advance to the final state (only
 432   4                                             // reading one byte)
 433   4      
 434   4                     break;
 435   4      
 436   4                  case SPI_READ_BUFFER:
 437   4                     SPI0DAT = 0xFF;         // Send a dummy byte so the Slave can
 438   4                                             // start sending the data
 439   4      
 440   4                     state = 1;              // Advance to the next state where the
 441   4                                             // data can be received
 442   4                                             // The data from the slave is not
 443   4                                             // available until after the second
 444   4                                             // transfer is completed.
 445   4                                             // The dummy byte allows the slave to
 446   4                                             // send data, since the Master controls
 447   4                                             // SCK.
 448   4      
 449   4                     break;
 450   4      
 451   4                  default:
 452   4                     state = 2;              // Any errors in the Command parsing
 453   4                                             // should go to state 2 where NSSMD0
 454   4                                             // is de-asserted
 455   4               }
 456   3            }
 457   2            else if (state == 1)             // This state is for READ_ARRAY
 458   2            {                                // commands where the data must be read
 459   3                                             // after the first dummy byte is sent
 460   3               switch (Command)
 461   3               {
 462   4                  case SPI_READ_BUFFER:
 463   4                     SPI_Data_Array[array_index] = SPI0DAT;
 464   4                     SPI0DAT = 0xFF;
 465   4      
 466   4                     array_index++;
 467   4      
 468   4                     if (array_index == (MAX_BUFFER_SIZE-1))
 469   4                     {
 470   5                        state = 2;
 471   5                     }
 472   4      
 473   4                     break;
 474   4                  default:
 475   4                     state = 2;              // Any errors in the Command parsing
 476   4                                             // should go to state 2 where NSSMD0
 477   4                                             // is de-asserted
 478   4               }
 479   3            }
 480   2            else if (state == 2)
 481   2            {
 482   3               switch (Command)
 483   3               {
 484   4                  case SPI_READ:
 485   4                     SPI_Data = SPI0DAT;     // Read the data from the slave
 486   4      
 487   4                     break;
 488   4      
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 9   

 489   4                  case SPI_READ_BUFFER:
 490   4                     SPI_Data_Array[array_index] = SPI0DAT; // Read the last data
 491   4                                                            // without sending a
 492   4                                                            // dummy byte
 493   4      
 494   4                     break;
 495   4               }
 496   3      
 497   3               NSSMD0 = 1;                   // De-select the Slave
 498   3      
 499   3               state = 0;                    // Reset the state
 500   3            }
 501   2      
 502   2            SPIF = 0;                        // Clear the SPIF flag
 503   2         }
 504   1      }
 505          
 506          //-----------------------------------------------------------------------------
 507          // Support Routines
 508          //-----------------------------------------------------------------------------
 509          
 510          //-----------------------------------------------------------------------------
 511          // SPI_LED_On
 512          //-----------------------------------------------------------------------------
 513          //
 514          // Return Value : None
 515          // Parameters   : None
 516          //
 517          // Turns the LED on the SPI Slave on.  The slave does not respond to this
 518          // command, so the command consists of:
 519          //
 520          // Command = SLAVE_LED_ON
 521          // Length = 1 byte (the command itself)
 522          //
 523          //-----------------------------------------------------------------------------
 524          void SPI_LED_On (void)
 525          {
 526   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 527   1                                             // it's already busy
 528   1      
 529   1         NSSMD0 = 0;
 530   1      
 531   1         Command = SLAVE_LED_ON;
 532   1      
 533   1         SPI0DAT = Command;
 534   1      
 535   1         // The rest of this command will be handled by the SPI ISR, which will
 536   1         // trigger when SPIF is set from sending the Command
 537   1      }
 538          
 539          //-----------------------------------------------------------------------------
 540          // SPI_LED_Off
 541          //-----------------------------------------------------------------------------
 542          //
 543          // Return Value : None
 544          // Parameters   : None
 545          //
 546          // Turns the LED on the SPI Slave off.  The slave does not respond to this
 547          // command, so the command consists of:
 548          //
 549          // Command = SLAVE_LED_OFF
 550          // Length = 1 byte (the command itself)
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 10  

 551          //
 552          //-----------------------------------------------------------------------------
 553          void SPI_LED_Off (void)
 554          {
 555   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 556   1                                             // it's already busy
 557   1      
 558   1         NSSMD0 = 0;
 559   1      
 560   1         Command = SLAVE_LED_OFF;
 561   1      
 562   1         SPI0DAT = Command;
 563   1      
 564   1         // The rest of this command will be handled by the SPI ISR, which will
 565   1         // trigger when SPIF is set from sending the Command
 566   1      }
 567          
 568          //-----------------------------------------------------------------------------
 569          // SPI_Byte_Write
 570          //-----------------------------------------------------------------------------
 571          //
 572          // Return Value : None
 573          // Parameters   : None
 574          //
 575          // Note: SPI_Data must contain the data to be sent before calling this
 576          // function.
 577          //
 578          // Writes a single byte to the SPI Slave.  The slave does not respond to this
 579          // command, so the command consists of:
 580          //
 581          // Command = SPI_WRITE
 582          // Length = 1 byte of command, 1 byte of data
 583          //
 584          //-----------------------------------------------------------------------------
 585          void SPI_Byte_Write (void)
 586          {
 587   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 588   1                                             // it's already busy
 589   1      
 590   1         NSSMD0 = 0;
 591   1      
 592   1         Command = SPI_WRITE;
 593   1      
 594   1         SPI0DAT = Command;
 595   1      
 596   1         // The rest of this command will be handled by the SPI ISR, which will
 597   1         // trigger when SPIF is set from sending the Command
 598   1      }
 599          
 600          //-----------------------------------------------------------------------------
 601          // SPI_Byte_Read
 602          //-----------------------------------------------------------------------------
 603          //
 604          // Return Value : None
 605          // Parameters   : None
 606          //
 607          // Note: SPI_Data will contain the data received after calling this function.
 608          //
 609          // Reads a single byte from the SPI Slave.  The command consists of:
 610          //
 611          // Command = SPI_READ
 612          // Length = 1 byte of command, 1 byte of data
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 11  

 613          //
 614          //-----------------------------------------------------------------------------
 615          void SPI_Byte_Read (void)
 616          {
 617   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 618   1                                             // it's already busy
 619   1      
 620   1         NSSMD0 = 0;
 621   1      
 622   1         Command = SPI_READ;
 623   1      
 624   1         SPI0DAT = 0x80 | cmd;
 625   1      
 626   1         // The rest of this command will be handled by the SPI ISR, which will
 627   1         // trigger when SPIF is set from sending the Command
 628   1      }
 629          
 630          //-----------------------------------------------------------------------------
 631          // SPI_Array_Write
 632          //-----------------------------------------------------------------------------
 633          //
 634          // Return Value : None
 635          // Parameters   : None
 636          //
 637          // Note: SPI_Data_Array must contain the data to be sent before calling this
 638          // function.
 639          //
 640          // Writes an array of values of size MAX_BUFFER_SIZE to the SPI Slave.  The
 641          // command consists of:
 642          //
 643          // Command = SPI_WRITE_BUFFER
 644          // Length = 1 byte of command, MAX_BUFFER_SIZE bytes of data
 645          //
 646          // Note: Polled mode is used for this function in order to buffer the data
 647          // being sent using the TXBMT flag.
 648          //
 649          //-----------------------------------------------------------------------------
 650          void SPI_Array_Write (void)
 651          {
 652   1         unsigned char array_index;
 653   1      
 654   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 655   1                                             // it's already busy
 656   1      
 657   1         ESPI0 = 0;                          // Disable SPI interrupts
 658   1      
 659   1         NSSMD0 = 0;
 660   1      
 661   1         SPI0DAT = SPI_WRITE_BUFFER;         // Load the XMIT register
 662   1         while (TXBMT != 1)                  // Wait until the command is moved into
 663   1         {                                   // the XMIT buffer
 664   2         }
 665   1      
 666   1         for (array_index = 0; array_index < MAX_BUFFER_SIZE; array_index++)
 667   1         {
 668   2            SPI0DAT = SPI_Data_Array[array_index]; // Load the data into the buffer
 669   2            while (TXBMT != 1)               // Wait until the data is moved into
 670   2            {                                // the XMIT buffer
 671   3            }
 672   2         }
 673   1         SPIF = 0;
 674   1         while (SPIF != 1)                   // Wait until the last byte of the
C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 12  

 675   1         {                                   // data reaches the Slave
 676   2         }
 677   1         SPIF = 0;
 678   1      
 679   1         NSSMD0 = 1;                         // Diable the Slave
 680   1      
 681   1         ESPI0 = 1;                          // Re-enable SPI interrupts
 682   1      }
 683          
 684          //-----------------------------------------------------------------------------
 685          // SPI_Array_Read
 686          //-----------------------------------------------------------------------------
 687          //
 688          // Return Value : None
 689          // Parameters   : None
 690          //
 691          // Note: SPI_Data_Array will contain the data received after calling this
 692          // function.
 693          //
 694          // Reads a single byte from the SPI Slave.  The command consists of:
 695          //
 696          // Command = SPI_READ_BUFFER
 697          // Length = 1 byte of command, MAX_BUFFER_SIZE bytes of data
 698          //
 699          //-----------------------------------------------------------------------------
 700          void SPI_Array_Read (void)
 701          {
 702   1         while (!NSSMD0);                    // Wait until the SPI is free, in case
 703   1                                             // it's already busy
 704   1      
 705   1         NSSMD0 = 0;
 706   1      
 707   1         Command = SPI_READ_BUFFER;
 708   1      
 709   1         SPI0DAT = Command;
 710   1      
 711   1         // The rest of this command will be handled by the SPI ISR, which will
 712   1         // trigger when SPIF is set from sending the Command
 713   1      }
 714          
 715          //-----------------------------------------------------------------------------
 716          // Delay
 717          //-----------------------------------------------------------------------------
 718          //
 719          // Return Value : None
 720          // Parameters   : None
 721          //
 722          // Delay for little while (used for blinking the LEDs)
 723          //
 724          //-----------------------------------------------------------------------------
 725          void Delay (void)
 726          {
 727   1         unsigned long count;
 728   1      
 729   1         for (count = 200000; count > 0; count--);
 730   1      }
 731          
 732          //-----------------------------------------------------------------------------
 733          // End Of File
 734          //-----------------------------------------------------------------------------


C51 COMPILER V9.50a   F31X_SPI0_MASTER                                                     12/14/2015 14:57:17 PAGE 13  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    414    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
